#= walley_prefunction.wy
# check -> , current_token , && || , else if , ; , // '' TL_subtl &
# string trim() should be rewritten like str = str.replace(/^\s+|\s+$/g,'')
# true -> true false -> false
INCOMPLETE_STATEMENT=false
#= FILE: walley_string.wy
def Walley_Print_Error(input_str,error_message,error_start_index) then
    console.log("Error.. %s\n",error_message)
    console.log("%s\n",input_str)
    local empty=""
    local i=0
    for  i<error_start_index, i=i+1 then
        empty=empty+" " 
    end
    empty=empty+"^"
    console.log("%s\n",empty)  
end
#= FILE: walley_data.wy
# Attenttion:
#   Token_List is just []
#token class


def Token_init() then
    local Token=[]
    Token.TOKEN_CLASS=""
    Token.TOKEN_STRING=""
    Token.TOKEN_START=-1
    Token.TOKEN_END=-1
    return Token    
end

#print token
TOKEN_print=def(token)then
	console.log(token.TOKEN_CLASS+":"+"|"+token.TOKEN_STRING+"|"+token.TOKEN_START+"|"+token.TOKEN_END)
end

#token list
# I remove token_list and its related functions
# Token_List now is just []
# convert token list to string

TL_toString=def(tl)then
	local return_string=""
	for i,v in tl then
		return_string=return_string+v.TOKEN_STRING
	end
end

TL_addToken=def(tl,add_token) then
	local temp_token=Token_init()
	temp_token.TOKEN_CLASS=add_token.TOKEN_CLASS
	temp_token.TOKEN_STRING=add_token.TOKEN_STRING
	temp_token.TOKEN_START=add_token.TOKEN_START
	temp_token.TOKEN_END=add_token.TOKEN_END
	tl.append(temp_token)
end

TL_indexOfTokenThatHasTokenString=def(tl, token_string) then
    local output=-1
    local i=0
    for i=0,i<tl.length,i=i+1 then
        if tl[i].TOKEN_STRING==token_string then
            return i
        end
    end
    return -1
end

def TL_indexOfTokenThatHasTokenClass(tl, token_string) then
    local output=-1
    local i=0
    for i=0,i<tl.length,i=i+1 then
        if tl[i].TOKEN_CLASS==token_string then
            return i
        end
    end
    return -1
end

#= walley_lexer.wy
match=def(input_str, index, match_string) then
	local length_of_input_str=input_str.length
    local length_of_match_str=match_string.length
    if index+length_of_match_str>length_of_input_str then
        return false
    end
    local i=0
    local match=true
    for i<length_of_match_str,i=i+1 then
        if input_str[index+i]!=match_string[i] then
            match=false
            break
        end
    end
    if match==true then
        return true
    else
        return false
    end
end

def term(input_str1,input_str2) then
    if input_str1==input_str2 then
        return true
    else
        return false
    end
end
    
def LIST_indexOfFinalBracket(input_str, index_of_first_bracket) then
    local count=0
    local in_string=false
    local length_of_input_str=input_str.length
    local i=index_of_first_bracket
    for  i<length_of_input_str, i=i+1 then
        if  in_string==false and input_str[i]=="\"" and input_str[i-1]!="\\" then
            in_string=true
            continue
        end
        if in_string==true and input_str[i]=="\"" and input_str[i-1]!="\\" then
            in_string=false
            continue
        end
        
        if in_string==false then
            if input_str[i]=="[" then
                count=count+1
                continue
            end
            if input_str[i]=="]" then
                count=count-1
                if count==0 then
                    return i
                else
                    continue
                end
            end
        end

    end
    
    return -1
end

def indexOfFinalDoubleQuote(input_str, first_index) then
    local first_char=input_str[first_index]
    local i=first_index+1
    local length=input_str.length
    if first_char=="\"" then
        for i<length, i=i+1 then
            if input_str[i]=="\"" and input_str[i-1]!="\\" then
                return i
            end
            
            if input_str[i]=="\"" and input_str[i-1]=="\\" then
                if input_str[i-2]=="\\" then
                    return i
                end
            end
        end
    end
   
    # did not find
    return -1
end

def Walley_Analyze_Token_Class(input_str, i) then
	# return obj
	# 0 --> end_index
	# 1 --> token class
	local return_obj=[]
    local length=input_str.length
    #  1  m_operator
    if match(input_str, i, "**") then
        end_index=i+2
        return_obj[0]=end_index
        return_obj[1]="m_operator"
        return return_obj
    end
    if match(input_str, i, "+") 
         or match(input_str, i, "-")
         or match(input_str, i, "*")
         or match(input_str, i, "/")
         or match(input_str, i, "^")
         or match(input_str, i, "%")
        then
        end_index=i+1
        return_obj[0]=end_index
        return_obj[1]="m_operator"
        return return_obj
    end
       
    #  2  punctuation
    if match(input_str,i,",")
        ## or match(input_str,i,";")  # remove support for ;
         or match(input_str,i,":")
        then
        end_index=i+1
        return_obj[0]=end_index
        return_obj[1]="punctuation"
        return return_obj
    end
    
    
    # 3 judge_sign
    # 1) i<length-1
    if match(input_str, i, "==")
         or match(input_str, i, ">=")
         or match(input_str, i, "<=")
         or match(input_str, i, "!=")
        then
        end_index=i+2
        return_obj[0]=end_index
        return_obj[1]="judge_sign"
        return return_obj
    end

    if input_str[i]==">"
         or input_str[i]=="<" then
        end_index=i+1
        return_obj[0]=end_index
        return_obj[1]="judge_sign"
        return return_obj
    end
    
    #~
    if match(input_str, i, "true") then
        end_index=i+4
        return_obj[0]=end_index
        return_obj[1]="true_of_false"
        return return_obj
    end

    if match(input_str, i, "false") then
        end_index=i+5
        return_obj[0]=end_index
        return_obj[1]="true_of_false"
        return return_obj
    end
    ~#
    
    # 4 relation
    # 1) and | not
    if (match(input_str, i, "and")
         or match(input_str, i, "not")) and
         (i+3>=length or input_str[i+3]==" " or input_str[i+3]=="\n")
        then
        end_index=i+3
        return_obj[0]=end_index
        return_obj[1]="relation"
        return return_obj
    end
    if match(input_str, i, "or") and (i+2>=length or input_str[i+2]==" " or input_str[i+2]=="\n") then
        end_index=i+2
        return_obj[0]=end_index
        return_obj[1]="relation"
        return return_obj
    end
    
    
    # 5 left_annotation
    if i<=length-2  and  input_str[i]=="#"  and  input_str[i+1]=="~" then
        end_index=i+2
        return_obj[0]=end_index
        return_obj[1]="l_annotation"
        return return_obj
    end
    
    # 6 right_annotation
    if i<=length-2 and (input_str[i]=="~"  and  input_str[i+1]=="#") then
        end_index=i+2
        return_obj[0]=end_index
        return_obj[1]="r_annotation"
    end
    
    # 7 keyword
    # 1) if
    if i<=length-2 and match(input_str,i,"if") and (i+2>=length or input_str[i+2]==" " or input_str[i+2]=="\n") then
         
        end_index=i+2
        return_obj[0]=end_index
        return_obj[1]="keyword"
        return return_obj
    end
    # 2)for def
    if (match(input_str, i, "for")
         or match(input_str, i,"def")) and
        (i+3>=length or input_str[i+3]==" " or input_str[i+3]=="\n")
          then
        #COUNT_THEN_END        
        end_index=i+3
        return_obj[0]=end_index
        return_obj[1]="keyword"
        return return_obj
    end

    # 3) elif else case
    if (match(input_str, i, "elif")
         or match(input_str, i, "else")
         or match(input_str, i, "case")) and
        (i+4>=length or input_str[i+4]==" " or input_str[i+4]=="\n")
          then
        end_index=i+4
        return_obj[0]=end_index
        return_obj[1]="keyword"
        return return_obj
    end
    
    # 4) while class
    if (match(input_str, i, "while")
         or match(input_str, i, "class"))
         and (i+5>=length or input_str[i+5]==" " or input_str[i+5]=="\n")
          then
     
        end_index=i+5
        return_obj[0]=end_index
        return_obj[1]="keyword"
        return return_obj
    end
    
    # then
    if match(input_str, i, "then")
        and (i+4>=length or input_str[i+4]==" " or input_str[i+4]=="\n")
        then
        end_index=i+4
        return_obj[0]=end_index
        return_obj[1]="then"
        return return_obj
    end
    
    # end
    if match(input_str, i, "end") and (i+3>=length or input_str[i+3]==" " or input_str[i+3]=="\n") then
       	end_index=i+3
       	return_obj[0]=end_index
       	return_obj[1]="end" 
       	return return_obj
    end
    
    # return
    #                                                 solve return_string problem
    if match(input_str, i, "return")  and  i+6<length  and  input_str[i+6]==" " then
        end_index=i+6
        return_obj[0]=end_index
        return_obj[1]="return"
        return return_obj
    end
    
    # local
    if match(input_str, i, "local")
       and (i+5>=length or input_str[i+5]==" " or input_str[i+5]=="\n")
     then
        end_index=i+5
        return_obj[0]=end_index
        return_obj[1]="local"
        return return_obj
    end
    
    # 5) switch
    if match(input_str, i, "switch") then
        end_index=i+6
        return_obj[0]=end_index
        return_obj[1]="keyword"
        return return_obj
    end
    
    # 8 assignment
    if input_str[i]=="=" then
        end_index=i+1
        return_obj[0]=end_index
        return_obj[1]="assignment_operator"
        return return_obj
    end

    
    # 9 annotation
    if input_str[i]=="#" then
        end_index=i+1
        return_obj[0]=end_index
        return_obj[1]="annotation"
        return return_obj
    end

    # 10 ()[]{}
    if input_str[i]=="("
        or input_str[i]==")"
        or input_str[i]=="{"
        or input_str[i]=="}"
       then
        end_index=i+1
        local output=input_str[i]
        return_obj[0]=end_index
        return_obj[1]=output
        return return_obj
    end
    
    if  input_str[i]=="[" then
        local index_of_final=LIST_indexOfFinalBracket(input_str, i)
        if index_of_final==-1 then
            INCOMPLETE_STATEMENT=true
        end
        end_index=index_of_final+1
        return_obj[0]=end_index
        return_obj[1]="list_table"
        return return_obj
    end
    
    # 11 string
    if input_str[i]=="\"" then
        local index_of_right_dq=indexOfFinalDoubleQuote(input_str, i)
        
        if index_of_right_dq==-1 then
            console.log("incomplete str\n")
            exit(0)
        else
            end_index=index_of_right_dq+1
            return_obj[0]=end_index
            return_obj[1]="string"
            return return_obj
        end
    end
    
    # 12 digit
    if isdigit(input_str[i])==true then
        local a=i+1
        local find_dot=false
        local index_of_first_dot=-1
        for a<length, a=a+1 then
            if input_str[a]=="."  and  find_dot==false then
                find_dot=true
                index_of_first_dot=a
                continue
            end
            if input_str[a]=="."  and  find_dot==true then
                # 1.2.3
                if isdigit(input_str[a+1]) then
                    Walley_Print_Error(input_str, "invalide number", a)
                # 1.2.toString
                # problem:
                # 1.2.3ToString()   func_name 3ToString
                else
                    end_index=a
                    return_obj[0]=end_index
                    return_obj[1]="num"
                    return return_obj
                end
            end
            if isdigit(input_str[a])==false then
                break
            end
        end
        if find_dot==true  and  isdigit(input_str[index_of_first_dot+1])==false then
            end_index=index_of_first_dot
            return_obj[0]=end_index
            return_obj[1]="num"
            return return_obj
        end
        if a!=length and isalpha(input_str[a]) then
            Walley_Print_Error(input_str, "Invalid Syntax", a)
        end
        
        end_index=a
        return_obj[0]=end_index
        return_obj[1]="num"
        return return_obj
    end
    
    # 13 white_space
    if input_str[i]==" "
         or input_str[i]=="\n"
         or input_str[i]=="\t" then
        local a=i+1
        for a<length, a=a+1 then
            if input_str[a]!=" "
                 and input_str[a]!="\n"
                 and input_str[a]!="\t" then
                break
            end
        end
        end_index=a
        return_obj[0]=end_index
        return_obj[1]="white_space"
        return return_obj
    end
    
    # 14 id
    # the first char can not be digit
    if isalpha(input_str[i]) or input_str[i]=="_" or input_str[i]=="$" then
        local a=i+1
        for a<length,a=a+1 then
            if isalpha(input_str[a]) or input_str[a]=="_" or input_str[a]=="$" or isdigit(input_str[a]) then
                continue
            else
                break
            end
        end

        end_index=a
        return_obj[0]=end_index
        return_obj[1]="id"
        return return_obj
    end
  
    # 15 dot
    if input_str[i]=="." then
        local a=i+1
        end_index=a
        return_obj[0]=end_index
        return_obj[1]="dot"
        return return_obj
    end
    
    # Error
    Walley_Print_Error(input_str, "Can not analyze this input", i)
    exit(0)
end

def Walley_Lexical_Analyzie(input_str) then
    local i=0
    local length=input_str.length
    local tl=[] # Token_List
    
    local end_index=0
    
    
    for i<length,i=i+1 then
        local output_data=Walley_Analyze_Token_Class(input_str,i,end_index)

        # set end_index and token_class
        end_index=output_data[0]
        local token_class=output_data[1]
        
        if INCOMPLETE_STATEMENT==true then
            break
        end

        # delete white_space
        if token_class=="white_space" then
            i=end_index-1
            continue
        end
        
        # annotation #
        if token_class=="annotation" then
             #find \n or length_of_input_str
            for i=end_index, i<length, i=i+1 then
                 if input_str[i]=="\n" then
                     break
                 end
            end
            continue

        end
        
        if token_class=="l_annotation" then
            i=end_index
            
            # find r_annotation
            local count=0 # check whether in string
            local find_right_annotation=false
            for  i<length-1, i=i+1 then
                if input_str[i]=="\"" then
                    count=count+1
                    continue
                end
                # find r_annotation
                if count%2==0 and input_str[i]=="~" and input_str[i+1]=="#" then
                    i=i+1
                    find_right_annotation=true
                    break
                end
            end
            
            # did not find right annotation
            # incomplete statements
            if find_right_annotation==false then
                INCOMPLETE_STATEMENT=true
                return tl
            end
            
            
            
            continue
        end
              
        temp_token=Token_init()
        temp_token.TOKEN_START=i
        temp_token.TOKEN_END=end_index
        temp_token.TOKEN_CLASS=token_class
        
        local token_string=""
        token_string=input_str[i:end_index]
        
        temp_token.TOKEN_STRING=token_string
        
        tl.append(temp_token)
     
        i=end_index-1
    end
    
       
    
    return tl
end

