def sentences_seperation(tl, output_tl,begin) then
    local length_of_tl=tl.length
    
    if begin.val>=length_of_tl then
        return FALSE
    end
    
    i=begin.val

    for  i<length_of_tl, i=i+1 then
       
        # from ( find )
        if term(tl[i].TOKEN_STRING, "(") then
            local index_of_right=-1
            local count=0

            for i<length_of_tl,i=i+1 then
                if term(tl[i].TOKEN_STRING,"(") then
                    count=count+1
                elif term(tl[i].TOKEN_STRING,")") then
                    count=count-1
                    if count==0 then
                        index_of_right=i
                        break
                    end
                end
            end
                        
            # did not find right
            if index_of_right==-1 then
                INCOMPLETE_STATEMENT=TRUE
                return FALSE
            # solve return a() and b() problem
           elif i+1<tl.length and (term(tl[i+1].TOKEN_STRING, "and") or term(tl[i+1].TOKEN_STRING, "or")) then
                 continue
            else
                local end_index=index_of_right+1
                output_tl.val=tl[begin.val:end_index]
                begin.val=i+1
                return TRUE
            end
        end
        
        # x=1 y=2 ->
        # x=1
        # y=2
        if i<length_of_tl-1 and (term(tl[i].TOKEN_CLASS, "num") or term(tl[i].TOKEN_CLASS, "string") or term(tl[i].TOKEN_CLASS, "id") or term(tl[i].TOKEN_CLASS, "list_table") or term(tl[i].TOKEN_STRING, ")"))
            and (term(tl[1+i].TOKEN_CLASS, "id") or term(tl[1+i].TOKEN_CLASS, "num")
                or term(tl[i+1].TOKEN_CLASS, "return") or term(tl[i+1].TOKEN_STRING, "continue") or term(tl[1+i].TOKEN_STRING, "break") or term(tl[1+i].TOKEN_CLASS, "local")) then
            local end_index=i+1
            local ahead_tl=tl[begin.val:end_index]
            output_tl.val=ahead_tl
            begin.val=end_index
            return TRUE
        end
        
        # find end corresponding to that def
        # def (num1,num2) return num1+num2 end
        # then set i to that end
        if term(tl[i].TOKEN_STRING, "def") or
            term(tl[i].TOKEN_STRING, "for") or 
            term(tl[i].TOKEN_STRING, "while") then
            
            # return ahead Token_List
            if begin.val!=i then
                if term(tl[i].TOKEN_STRING, "def") and term(tl[1].TOKEN_STRING, "(") then
                   #nothing 
                   console.log("")
                else
                    local end_index=i
                    local ahead_tl=tl[begin.val:end_index]
                
                    begin.val=end_index
                    output_tl.val=ahead_tl
                    return TRUE
                end
            end
            
            local count=0
            for i<length_of_tl, i=i+1 then
                if term(tl[i].TOKEN_STRING, "def")
                    or term(tl[i].TOKEN_STRING, "for")
                    or term(tl[i].TOKEN_STRING, "if")
                    or term(tl[i].TOKEN_STRING, "while") then
                    count=count+1
                end
                if term(tl[i].TOKEN_STRING, "end") then
                    count=count-1
                end
                if count==0 then
                    break
                end
            end
            
            if count==0 then
                local end_index=i+1
                local ahead_tl=tl[begin.val:end_index]
                output_tl.val=ahead_tl
                begin.val=end_index
                return TRUE
            else
                INCOMPLETE_STATEMENT=TRUE
                return FALSE
            end
        end
        
        
        # find 'end' or 'elif' or 'else'
        # if no 'end' found--- incomplete
        # if find 'elif' or 'else', add 'end' manually
        if term(tl[i].TOKEN_STRING, "if") then 
            # return ahead Token_List
            if begin.val!=i then
                
                local end_index=i
                local ahead_tl=tl[begin.val:end_index]
                begin.val=end_index
                output_tl.val=ahead_tl
                return TRUE
            end
            
            
            local count_of_if=0
            local count_of_end=0
            for  i<length_of_tl,i=i+1 then
                if term(tl[i].TOKEN_STRING, "if")
                or term(tl[i].TOKEN_STRING, "def")
                or term(tl[i].TOKEN_STRING, "while")
                or term(tl[i].TOKEN_STRING, "for") then
                    count_of_if=count_of_if+1
                    count_of_end=count_of_end+1
                end
                
                if term(tl[i].TOKEN_STRING, "end") then
                    count_of_if=count_of_if-1
                    count_of_end=count_of_end-1
                end
                
                if count_of_end==0 then
                    break
                end
                
                if count_of_if==1 and
                    (term(tl[i].TOKEN_STRING, "elif")
                     or term(tl[i].TOKEN_STRING, "else"))
                    then
                    
                    local end_index=i
                    local ahead_tl=tl[begin.val:end_index]
                    local end_token=Token_init()
                    end_token.TOKEN_STRING="end"
                    end_token.TOKEN_CLASS="end"
                    ahead_tl.append(end_token)
                    
                    begin.val=end_index
                    output_tl.val=ahead_tl
                    
                    return TRUE
                end
            end
            
            # incomplete
            if count_of_if!=count_of_end or count_of_if!=0 then
                INCOMPLETE_STATEMENT=TRUE
                return FALSE
            # complete
            #~
             eg: 
             if x>0 then
                if x>3 then
                    x=12
                end
             end
             
            ~# 
            else
                local end_index=i+1
                local ahead_tl=tl[begin.val:end_index]
                
                begin.val=end_index-1
                output_tl.val=ahead_tl
                return TRUE
            end
        end
        
        # elif
        if term(tl[i].TOKEN_STRING, "elif") then
            local count_of_if=0
            local count_of_end=0
            local temp_i=i
            for  i<length_of_tl, i=i+1 then
                if term(tl[i].TOKEN_STRING, "if")
                or term(tl[i].TOKEN_STRING, "def")
                or term(tl[i].TOKEN_STRING, "while")
                or term(tl[i].TOKEN_STRING, "for") then
                    count_of_if=count_of_if+1
                    count_of_end=count_of_end+1
                end
                
                if term(tl[i].TOKEN_STRING, "end") then
                    count_of_end=count_of_end-1
                    count_of_if=count_of_if-1
                end
                
                # find elif or else
                if count_of_if==0 and i!=temp_i and
                    ( term(tl[i].TOKEN_STRING, "elif") or
                     term(tl[i].TOKEN_STRING, "else")
                     )
                    then
                    local end_index=i
                    local ahead_tl=tl[begin.val:end_index]
                    
                    local end_token=Token_init()
                    end_token.TOKEN_STRING="end"
                    end_token.TOKEN_CLASS="end"
                    ahead_tl.append(end_token)
                    
                    begin.val=end_index
                    output_tl.val=ahead_tl
                    return TRUE
                end
                # elif then ... end
                if count_of_end==-1 and count_of_if==-1 then
                    local end_index=i+1
                    local ahead_tl=tl[begin.val:end_index]
                    
                    begin.val=end_index-1
                    output_tl.val=ahead_tl
                    return TRUE
                end
            end
            
            # incomplete
            INCOMPLETE_STATEMENT=TRUE
            return FALSE
    
            
        end
        
        # else
        if term(tl[i].TOKEN_STRING, "else") then
            local count_of_if=0
            local count_of_end=0
            local temp_i=i
            for i<length_of_tl,i=i+1 then
                if term(tl[i].TOKEN_STRING, "if")
                or term(tl[i].TOKEN_STRING, "def")
                or term(tl[i].TOKEN_STRING, "while")
                or term(tl[i].TOKEN_STRING, "for") then
                    count_of_if=count_of_if+1
                    count_of_end=count_of_end+1
                end
                if term(tl[i].TOKEN_STRING, "end") then
                    count_of_if=count_of_if-1
                    count_of_end=count_of_end-1
                end
                
                #error
                if count_of_if==0 and i!=temp_i and (term(tl[i].TOKEN_STRING, "elif") or term(tl[i].TOKEN_STRING, "else")) then
                    Walley_Print_Error(TL_toString(temp_tl), "elif or else statements error", tl[i].TOKEN_START)
                end
                
                # finish else
                if count_of_end==-1 then
                    local end_index=i+1
                    local ahead_tl=tl[begin.val:end_index]
                    
                    begin.val=end_index-1
                    output_tl.val=ahead_tl
                    return TRUE

                end
            end
            
            INCOMPLETE_STATEMENT=TRUE
            return FALSE
        end
    
        # end->
        # end
        if term(tl[i].TOKEN_STRING, "end") then
            local end_index=i
            if begin.val<i then
                local ahead_tl=tl[begin.val:end_index]
                
                begin.val=end_index
                output_tl.val=ahead_tl
                return TRUE
            
            else
                begin.val=end_index
            end
            
            
            end_index=i+1
            local ahead_tl=tl[begin.val:end_index]
            
            begin.val=end_index
            output_tl.val=ahead_tl
            return TRUE
        end
    end
    if begin.val<length_of_tl then
        local ahead_tl=tl[begin.val:length_of_tl]
       
        begin.val=length_of_tl
        output_tl.val=ahead_tl
        return TRUE
    end
    
    return FALSE
end
