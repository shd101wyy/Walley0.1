#= walley_prefunction.wy
# check -> , current_token , && || , else if , ; , // '' TL_subtl &
# string trim() should be rewritten like str = str.replace(/^\s+|\s+$/g,'')
# true -> true false -> false
if typeof(exports) == "undefined" then
    exports=[]
end
INCOMPLETE_STATEMENT=false
#= FILE: walley_string.wy
def toString(input_str) then
    if input_str[0]=="\"" then
        return input_str
    else
        return "\""+input_str+"\""
    end
end
def Walley_Print_Error(input_str,error_message,error_start_index) then
    console.log("Error.. %s\n",error_message)
    console.log("%s\n",input_str)
    local empty=""
    local i=0
    for  i<error_start_index, i=i+1 then
        empty=empty+" " 
    end
    empty=empty+"^"
    console.log("%s\n",empty)  
end
#= FILE: walley_data.wy
# Attenttion:
#   Token_List is just []
#token class


def Token_init() then
    local Token=[]
    Token.TOKEN_CLASS=""
    Token.TOKEN_STRING=""
    Token.TOKEN_START=-1
    Token.TOKEN_END=-1
    return Token    
end

#print token
TOKEN_print=def(token)then
	console.log(token.TOKEN_CLASS+":"+"|"+token.TOKEN_STRING+"|"+token.TOKEN_START+"|"+token.TOKEN_END)
end

#token list
# I remove token_list and its related functions
# Token_List now is just []
# convert token list to string

TL_toString=def(tl)then
	local return_string=""
	for i,v in tl then
		return_string=return_string+v.TOKEN_STRING
	end
end

TL_addToken=def(tl,add_token) then
	local temp_token=Token_init()
	temp_token.TOKEN_CLASS=add_token.TOKEN_CLASS
	temp_token.TOKEN_STRING=add_token.TOKEN_STRING
	temp_token.TOKEN_START=add_token.TOKEN_START
	temp_token.TOKEN_END=add_token.TOKEN_END
	tl.append(temp_token)
end

TL_indexOfTokenThatHasTokenString=def(tl, token_string) then
    local output=-1
    local i=0
    for i=0,i<len(tl),i=i+1 then
        if tl[i].TOKEN_STRING==token_string then
            return i
        end
    end
    return -1
end

def TL_indexOfTokenThatHasTokenClass(tl, token_string) then
    local output=-1
    local i=0
    for i=0,i<len(tl),i=i+1 then
        if tl[i].TOKEN_CLASS==token_string then
            return i
        end
    end
    return -1
end

#= walley_lexer.wy
match=def(input_str, index, match_string) then
	local length_of_input_str=len(input_str)
    local length_of_match_str=len(match_string)
    if index+length_of_match_str>length_of_input_str then
        return false
    end
    local i=0
    local match=true
    for i<length_of_match_str,i=i+1 then
        if input_str[index+i]!=match_string[i] then
            match=false
            break
        end
    end
    if match==true then
        return true
    else
        return false
    end
end

def term(input_str1,input_str2) then
    if input_str1==input_str2 then
        return true
    else
        return false
    end
end
    
def LIST_indexOfFinalBracket(input_str, index_of_first_bracket) then
    local count=0
    local in_string=false
    local length_of_input_str=len(input_str)
    local i=index_of_first_bracket
    for  i<length_of_input_str, i=i+1 then
        if  in_string==false and input_str[i]=="\"" and input_str[i-1]!="\\" then
            in_string=true
            continue
        end
        if in_string==true and input_str[i]=="\"" and input_str[i-1]!="\\" then
            in_string=false
            continue
        end
        
        if in_string==false then
            if input_str[i]=="[" then
                count=count+1
                continue
            end
            if input_str[i]=="]" then
                count=count-1
                if count==0 then
                    return i
                else
                    continue
                end
            end
        end

    end
    
    return -1
end

def indexOfFinalDoubleQuote(input_str, first_index) then
    local first_char=input_str[first_index]
    local i=first_index+1
    local length=len(input_str)
    if first_char=="\"" then
        for i<length, i=i+1 then
            if input_str[i]=="\"" and input_str[i-1]!="\\" then
                return i
            end
            
            if input_str[i]=="\"" and input_str[i-1]=="\\" then
                if input_str[i-2]=="\\" then
                    return i
                end
            end
        end
    end
   
    # did not find
    return -1
end

def Walley_Analyze_Token_Class(input_str, i) then
	# return obj
	# 0 --> end_index
	# 1 --> token class
	local return_obj=[]
    local length=len(input_str)

    # solve && || error
    if match(input_str,i,"&&") or match(input_str,i,"||") then
        console.log("Error.. Does not support && and ||")
        console.log("Please use ' and ' and ' or ' instead")
    end

    # add ++ -- like x++ or x--
    # ++ -- --> self_operator
    # var_name self_operator
    if match(input_str,i,"++") or match(input_str,i,"--") then
        end_index=i+2
        return_obj[0]=end_index
        return_obj[1]="self_operator"
        return return_obj
    end

    # add += -= *= /= %= support
    # does not support **= and ^= now
    if match(input_str,i,"+=") or match(input_str,i,"-=") or match(input_str,i,"*=") or match(input_str,i,"//=") or match(input_str,i,"%=") then
        end_index=i+2
        return_obj[0]=end_index
        return_obj[1]="self_assignment"
        return return_obj
    end

    #  1  m_operator
    if match(input_str, i, "**") then
        end_index=i+2
        return_obj[0]=end_index
        return_obj[1]="m_operator"
        return return_obj
    end
    if match(input_str, i, "+") 
         or match(input_str, i, "-")
         or match(input_str, i, "*")
         or match(input_str, i, "/")
         or match(input_str, i, "^")
         or match(input_str, i, "%")
        then
        end_index=i+1
        return_obj[0]=end_index
        return_obj[1]="m_operator"
        return return_obj
    end
       
    #  2  punctuation
    if match(input_str,i,",")
        ## or match(input_str,i,";")  # remove support for ;
         or match(input_str,i,":")
        then
        end_index=i+1
        return_obj[0]=end_index
        return_obj[1]="punctuation"
        return return_obj
    end
    
    
    # 3 judge_sign
    # 1) i<length-1
    if match(input_str, i, "==")
         or match(input_str, i, ">=")
         or match(input_str, i, "<=")
         or match(input_str, i, "!=")
        then
        end_index=i+2
        return_obj[0]=end_index
        return_obj[1]="judge_sign"
        return return_obj
    end

    if input_str[i]==">"
         or input_str[i]=="<" then
        end_index=i+1
        return_obj[0]=end_index
        return_obj[1]="judge_sign"
        return return_obj
    end

    # add import support
    # import "hello.wy"
    # import all content in hello.wy
    if match(input_str,i,"import") then
        end_index=i+6
        return_obj[0]=end_index
        return_obj[1]="import"
        return return_obj
    end
    
    #~
    if match(input_str, i, "true") then
        end_index=i+4
        return_obj[0]=end_index
        return_obj[1]="true_of_false"
        return return_obj
    end

    if match(input_str, i, "false") then
        end_index=i+5
        return_obj[0]=end_index
        return_obj[1]="true_of_false"
        return return_obj
    end
    ~#
    
    # 4 relation
    # 1) and | not
    if (match(input_str, i, "and")
         or match(input_str, i, "not")) and
         (i+3>=length or input_str[i+3]==" " or input_str[i+3]=="\n")
        then
        end_index=i+3
        return_obj[0]=end_index
        return_obj[1]="relation"
        return return_obj
    end
    if match(input_str, i, "or") and (i+2>=length or input_str[i+2]==" " or input_str[i+2]=="\n") then
        end_index=i+2
        return_obj[0]=end_index
        return_obj[1]="relation"
        return return_obj
    end
    
    
    # 5 left_annotation
    if i<=length-2  and  input_str[i]=="#"  and  input_str[i+1]=="~" then
        end_index=i+2
        return_obj[0]=end_index
        return_obj[1]="l_annotation"
        return return_obj
    end
    
    # 6 right_annotation
    if i<=length-2 and (input_str[i]=="~"  and  input_str[i+1]=="#") then
        end_index=i+2
        return_obj[0]=end_index
        return_obj[1]="r_annotation"
    end
    
    # 7 keyword
    # 1) if
    if i<=length-2 and match(input_str,i,"if") and (i+2>=length or input_str[i+2]==" " or input_str[i+2]=="\n") then
         
        end_index=i+2
        return_obj[0]=end_index
        return_obj[1]="keyword"
        return return_obj
    end
    # 2)for def
    if (match(input_str, i, "for")
         or match(input_str, i,"def")) and
        (i+3>=length or input_str[i+3]==" " or input_str[i+3]=="\n")
          then
        #COUNT_THEN_END        
        end_index=i+3
        return_obj[0]=end_index
        return_obj[1]="keyword"
        return return_obj
    end

    # 3) elif else case
    if (match(input_str, i, "elif")
         or match(input_str, i, "else")
         or match(input_str, i, "case")) and
        (i+4>=length or input_str[i+4]==" " or input_str[i+4]=="\n")
          then
        end_index=i+4
        return_obj[0]=end_index
        return_obj[1]="keyword"
        return return_obj
    end
    
    # 4) while class
    if (match(input_str, i, "while")
         or match(input_str, i, "class"))
         and (i+5>=length or input_str[i+5]==" " or input_str[i+5]=="\n")
          then
     
        end_index=i+5
        return_obj[0]=end_index
        return_obj[1]="keyword"
        return return_obj
    end
    
    # then
    if match(input_str, i, "then")
        and (i+4>=length or input_str[i+4]==" " or input_str[i+4]=="\n")
        then
        end_index=i+4
        return_obj[0]=end_index
        return_obj[1]="then"
        return return_obj
    end
    
    # end
    if match(input_str, i, "end") and (i+3>=length or input_str[i+3]==" " or input_str[i+3]=="\n") then
       	end_index=i+3
       	return_obj[0]=end_index
       	return_obj[1]="end" 
       	return return_obj
    end
    
    # return
    #                                                 solve return_string problem
    if match(input_str, i, "return")  and  i+6<length  and  input_str[i+6]==" " then
        end_index=i+6
        return_obj[0]=end_index
        return_obj[1]="return"
        return return_obj
    end
    
    # local
    if match(input_str, i, "local")
       and (i+5>=length or input_str[i+5]==" " or input_str[i+5]=="\n")
     then
        end_index=i+5
        return_obj[0]=end_index
        return_obj[1]="local"
        return return_obj
    end
    
    # 5) switch
    if match(input_str, i, "switch") then
        end_index=i+6
        return_obj[0]=end_index
        return_obj[1]="keyword"
        return return_obj
    end
    
    # 8 assignment
    if input_str[i]=="=" then
        end_index=i+1
        return_obj[0]=end_index
        return_obj[1]="assignment_operator"
        return return_obj
    end

    
    # 9 annotation
    if input_str[i]=="#" then
        end_index=i+1
        return_obj[0]=end_index
        return_obj[1]="annotation"
        return return_obj
    end

    # 10 ()[]{}
    if input_str[i]=="("
        or input_str[i]==")"
        or input_str[i]=="{"
        or input_str[i]=="}"
       then
        end_index=i+1
        local output=input_str[i]
        return_obj[0]=end_index
        return_obj[1]=output
        return return_obj
    end
    
    if  input_str[i]=="[" then
        local index_of_final=LIST_indexOfFinalBracket(input_str, i)
        if index_of_final==-1 then
            INCOMPLETE_STATEMENT=true
        end
        end_index=index_of_final+1
        return_obj[0]=end_index
        return_obj[1]="list_table"
        return return_obj
    end
    
    # 11 string
    if input_str[i]=="\"" then
        local index_of_right_dq=indexOfFinalDoubleQuote(input_str, i)
        
        if index_of_right_dq==-1 then
            console.log("incomplete str\n")
            process.exit(0)
        else
            end_index=index_of_right_dq+1
            return_obj[0]=end_index
            return_obj[1]="string"
            return return_obj
        end
    end
    
    # 12 digit
    if isdigit(input_str[i]) == true then
        local a=i
        local temp_str=input_str[i]
        while isdigit(temp_str) then
            a=a+1
            temp_str=temp_str+input_str[a]
        end
        end_index = a
        return_obj[0] = end_index
        return_obj[1] = "num"
        return return_obj
    end
    
    # 13 white_space
    if input_str[i]==" "
         or input_str[i]=="\n"
         or input_str[i]=="\t" then
        local a=i+1
        for a<length, a=a+1 then
            if input_str[a]!=" "
                 and input_str[a]!="\n"
                 and input_str[a]!="\t" then
                break
            end
        end
        end_index=a
        return_obj[0]=end_index
        return_obj[1]="white_space"
        return return_obj
    end
    
    # 14 id
    # the first char can not be digit
    if isalpha(input_str[i]) or input_str[i]=="_" or input_str[i]=="$" then
        local a=i+1
        for a<length,a=a+1 then
            if isalpha(input_str[a]) or input_str[a]=="_" or input_str[a]=="$" or isdigit(input_str[a]) then
                continue
            else
                break
            end
        end

        end_index=a
        return_obj[0]=end_index
        return_obj[1]="id"
        return return_obj
    end
  
    # 15 dot
    if input_str[i]=="." then
        local a=i+1
        end_index=a
        return_obj[0]=end_index
        return_obj[1]="dot"
        return return_obj
    end
    
    # Error
    Walley_Print_Error(input_str, "Can not analyze this input", i)
    process.exit(0)
end

def Walley_Lexical_Analyzie(input_str) then
    local i=0
    local length=len(input_str)
    local tl=[] # Token_List
    
    local end_index=0
    
    
    for i<length,i=i+1 then
        local output_data=Walley_Analyze_Token_Class(input_str,i)

        # set end_index and token_class
        end_index=output_data[0]
        local token_class=output_data[1]
        
        if INCOMPLETE_STATEMENT==true then
            break
        end

        # delete white_space
        if token_class=="white_space" then
            i=end_index-1
            continue
        end
        
        # annotation #
        if token_class=="annotation" then
             #find \n or length_of_input_str
            for i=end_index, i<length, i=i+1 then
                 if input_str[i]=="\n" then
                     break
                 end
            end
            continue

        end
        
        if token_class=="l_annotation" then
            i=end_index
            
            # find r_annotation
            local count=0 # check whether in string
            local find_right_annotation=false
            for  i<length-1, i=i+1 then
                if input_str[i]=="\"" then
                    count=count+1
                    continue
                end
                # find r_annotation
                if count%2==0 and input_str[i]=="~" and input_str[i+1]=="#" then
                    i=i+1
                    find_right_annotation=true
                    break
                end
            end
            
            # did not find right annotation
            # incomplete statements
            if find_right_annotation==false then
                INCOMPLETE_STATEMENT=true
                return tl
            end
            
            
            
            continue
        end
              
        temp_token=Token_init()
        temp_token.TOKEN_START=i
        temp_token.TOKEN_END=end_index
        temp_token.TOKEN_CLASS=token_class
        
        local token_string=""
        token_string=input_str[i:end_index].trim()
        
        temp_token.TOKEN_STRING=token_string
        
        tl.append(temp_token)
     
        i=end_index-1
    end
    
       
    
    return tl
end






#= walley_tree.wy
# I delete all functions relevent with node_list  ***
# now Node_List is just []
TREE_INDEX=0

# define TREE object
def TREE_init(name) then
    local TREE=[]
    TREE.name=name or ""
    TREE.token_class=""
    TREE.index=0
    TREE.layer=0
    TREE.node_list=[]
    TREE_INDEX=TREE_INDEX+1
    return TREE
end

TREE_addNode = def(tree, name, token_class) then
    local length_of_nl=len(tree.node_list)
    tree["node_list"][length_of_nl]=TREE_init()
    tree["node_list"][length_of_nl]["name"] = name
    tree["node_list"][length_of_nl]["token_class"] = token_class
    tree["node_list"][length_of_nl]["index"] = TREE_INDEX-1
    tree["node_list"][length_of_nl]["layer"] = tree["layer"] + 1
    tree["node_list"][length_of_nl]["node_list"] = []
end

def TREE_addTree(tree, add_tree) then
    local index = TREE_INDEX
    local length_of_nl=len(tree["node_list"])
    tree["node_list"][length_of_nl] = add_tree
    tree["node_list"][length_of_nl]["index"] = index
    tree["node_list"][length_of_nl]["layer"] = tree["layer"] + 1
    TREE_INDEX = TREE_INDEX + 1
end


def TREE_getTreeAccordingToIndex( tree, index) then
    
    if index==tree.index then
        return tree
    else
        local nl=tree.node_list # Node_List
        if len(nl)==0 then
            return none
        end

        local i=0
        local length=len(nl)
        for i<length, i=i+1 then
            local node=nl[i]
            if index==node.index then
                return node
            end
        end

        nl=tree.node_list # Node_List
        i=0
        for  i<length , i=i+1 then
            found_tree=TREE_getTreeAccordingToIndex(nl[i], index)
            if found_tree!=none then
                return found_tree
            end
        end    
    end
    return none
end

def TREE_print(tree) then
    process["stdout"]["write"]("("+tree["token_class"]+" "+tree["name"])
    local length_of_node_list = len(tree["node_list"])
    if length_of_node_list != 0 then
        local i = 0
        local nl = tree["node_list"]
        for i = 0, i < length_of_node_list, i = i + 1 then
            TREE_print(nl[i])
        end
    end
    process["stdout"]["write"](")")
end

def TREE_changeNameAccordingToIndex(tree, index, change_to_name) then
    local temp_tree=TREE_getTreeAccordingToIndex(tree, index)
    temp_tree.name=change_to_name
end

# return the layer num of TREE
def TREE_layer(tree) then
    local temp_tree=TREE_getTreeAccordingToIndex(tree, TREE_INDEX)
    return temp_tree.layer
end

def TREE_addNodeAtIndex(tree, index, add_name, add_token_class) then
    local temp_tree=TREE_getTreeAccordingToIndex(tree, index)
    TREE_addNode(temp_tree, add_name, add_token_class)
end

#= walley_list.wy
def elements(tree, tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    local length_of_tl=len(tl)
    local index_of_comma=TL_indexOfTokenThatHasTokenString(tl, ",")
    # value
    if index_of_comma==-1 then
        local index_of_tl=TREE_INDEX
        TREE_addNode(tree,"value","")
        return value(TREE_getTreeAccordingToIndex(tree, index_of_tl), tl)
    # value ',' elements
    else
        local tl1=tl[0:index_of_comma]
        local tl2=tl[index_of_comma+1:length_of_tl]
        
        local index_of_tl1=TREE_INDEX
        TREE_addNode(tree,"value","")
       
        
        return value(TREE_getTreeAccordingToIndex(tree, index_of_tl1), tl1) and elements(tree, tl2)
    end
end


def value(tree, tl) then

    if INCOMPLETE_STATEMENT then
        return false
    end
    
    local length_of_tl=len(tl)

    # (null)
    if length_of_tl==0 then
        tree.name="none"
        tree.token_class="id"
        return true
    elif length_of_tl==1 then
        #   num
        #  | id
        #  | string
        if "num"==tl[0].TOKEN_CLASS
            or "string"==tl[0].TOKEN_CLASS
            or "id"==tl[0].TOKEN_CLASS then
            tree.name=tl[0].TOKEN_STRING
            tree.token_class=tl[0].TOKEN_CLASS
            return true
        # | list
        # | table
        elif "list_table"==tl[0].TOKEN_CLASS then
            tree.name=tl[0].TOKEN_STRING
            tree.token_class="table"

            # I changed key_index here to object
            local key_index=[val=0]
            return table(tree, tl,key_index)
        else
            return false
        end
    # func_value
    # table_value
    # func
    # relation
    # expr
    else 
        return func_value(tree, tl) or table_value(tree, tl) or func(tree, tl) or relation(tree,tl) or expr(tree, tl)
    end
end


#= walley.table.wy
# key_index is object [val=0]
def table_elements(tree, tl,key_index) then
    if INCOMPLETE_STATEMENT then
        return false
    end
    local length_of_tl=len(tl)
    local i=0
    local index_of_comma=-1

    for i=0,i<length_of_tl,i=i+1 then
        if term(tl[i].TOKEN_STRING,",") then
            index_of_comma=i
            break
        end
    end
    #| table_expr ',' table_elements
    if index_of_comma!=-1 then
        table_expr_tl=tl[0:index_of_comma]
        table_elements_tl=tl[index_of_comma+1:length_of_tl]
        local index1=TREE_INDEX
        TREE_addNode(tree, "table_expr", "")

        return table_expr(TREE_getTreeAccordingToIndex(tree, index1), table_expr_tl, key_index)
        and table_elements(tree, table_elements_tl, key_index)
    else
        local index=TREE_INDEX
        TREE_addNode(tree, "table_expr", "")
        return table_expr(TREE_getTreeAccordingToIndex(tree, index), tl, key_index)
    end
end


def table_expr(tree,tl,key_index) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end

    local length_of_tl=len(tl)
    # | '@' id '=' value
    if length_of_tl>3 and term(tl[0].TOKEN_CLASS, "@") and term(tl[1].TOKEN_CLASS, "id") and term(tl[2].TOKEN_STRING, "=") then
        local append_key=tl[1].TOKEN_STRING
        local length_of_append_key=len(append_key)
        local new_key="@"+append_key
        # THIS PLACE HAS PROBLEM WHILE PARSING KEY
        TREE_addNode(tree, new_key, "key")
        local index=TREE_INDEX
        TREE_addNode(tree, "value", "")
        return value(TREE_getTreeAccordingToIndex(tree, index), tl[3:length_of_tl])
    
    # id '=' value
    elif term(tl[0].TOKEN_CLASS, "id") and term(tl[1].TOKEN_STRING, "=") then
        local index1=TREE_INDEX
        TREE_addNode(tree, "key", "")
        
        local key_tl=Walley_Lexical_Analyzie(toString(tl[0].TOKEN_STRING))

        local key_tree=TREE_init("key")
        value(key_tree, key_tl)
        
        TREE_addTree(TREE_getTreeAccordingToIndex(tree, index1),key_tree)

        local index2=TREE_INDEX
        TREE_addNode(tree, "value", "")
        return value(TREE_getTreeAccordingToIndex(tree, index2), tl[2:length_of_tl])
    #              0           1       2
    #    |'[' (string|int) ']' '=' (value)
    elif term(tl[0].TOKEN_CLASS, "list_table") and tl[1]!=undefined and term(tl[1].TOKEN_STRING, "=") then
        # THIS PLACE HAS SOME PROBLEM
        #printf("'[' (string|int) ']' '=' (value)  HAS NOT BEEN IMPLEMENTED\n")
        
        local length=len(tl[0].TOKEN_STRING)
        local string_inside= tl[0].TOKEN_STRING[1:length-1]   
        
        local index1=TREE_INDEX
        TREE_addNode(tree, "key", "")
        
        local key_tl=Walley_Lexical_Analyzie(string_inside)
        TREE key_tree=TREE_init("key")
        value(key_tree, key_tl)
        
        TREE_addTree(TREE_getTreeAccordingToIndex(tree, index1),key_tree)
        
        local index2=TREE_INDEX
        TREE_addNode(tree, "value", "")
        
        
        return value(TREE_getTreeAccordingToIndex(tree, index2),tl[2:length_of_tl])

    #value
    else
        local index1=TREE_INDEX
        TREE_addNode(tree, "key", "")
        
        local key_tl=Walley_Lexical_Analyzie(key_index.val+"")
        local key_tree=TREE_init("key")
        value(key_tree, key_tl)
        
        TREE_addTree(TREE_getTreeAccordingToIndex(tree, index1),key_tree)
        
        
        local index=TREE_INDEX
        TREE_addNode(tree, "value", "")
      
        
        key_index.val=key_index.val+1
        
        return value(TREE_getTreeAccordingToIndex(tree, index),tl)
    end

    return false
end

#table    -> '[' table_elements ']'
def table(tree,tl,key_index) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    local length_of_tl=len(tl)
    
    if length_of_tl==1 then
        local list_string=tl[0].TOKEN_STRING
        local length_of_list_string=len(list_string)
        if list_string[0]=="[" and list_string[length_of_list_string-1]=="]" then
            # list_string [1,2]
            # list_string2 1,2
            local list_string2=list_string[1:len(list_string)-1].trim()
            
            # content empty
            # x=[]
            if list_string2=="" then
                return true
            end
            
            
            local table_tl=Walley_Lexical_Analyzie(list_string2)
            return table_elements(tree, table_tl, key_index)
        else
            return false
        end
    
    else
        return false
    end
end


def table_value(tree, tl) then
    
    if INCOMPLETE_STATEMENT==true then
        return false
    end
   
    local length_of_tl=len(tl)

    # check whether have m_operator to solve len(a)-1 parser error
    local i=0
    local count=0
    for i=0,i<length_of_tl,i=i+1 then
        if term(tl[i].TOKEN_STRING,"(") then
            count=count+1
        elif term(tl[i].TOKEN_STRING,")") then
            count=count-1
        end

        if count==0 and term(tl[i].TOKEN_CLASS,"m_operator") then
            return false
        end
    end

    #~
     id table_value_key
     
     // new support
     string table_value_key              // "hello".length()
     list_table table_value_key          // [1,2,3].length()
     num table_value_key                 //  13.toString()
     ~#
    if length_of_tl>=2 and
        (term(tl[0].TOKEN_CLASS, "id")
         or term(tl[0].TOKEN_CLASS, "string")
         or term(tl[0].TOKEN_CLASS, "list_table")
         or term(tl[0].TOKEN_CLASS, "num")
        )
        and
        (term(tl[1].TOKEN_STRING, ".") or term(tl[1].TOKEN_CLASS, "list_table"))
         then
        local index=TREE_INDEX
        TREE_addNode(tree, "table_value", "")
        
        
        TREE_addNode(TREE_getTreeAccordingToIndex(tree, index), tl[0].TOKEN_STRING, tl[0].TOKEN_CLASS)
        return table_value_key(TREE_getTreeAccordingToIndex(tree, index), tl[1:length_of_tl])
    # new support on 05/24/2013
    #func table_value_key
    elif length_of_tl>=3 and term(tl[0].TOKEN_CLASS, "id") and term(tl[1].TOKEN_STRING, "(") then
        local index=-1 # find index of )
        
        local i=0
        local count=0
        for i=0,i<len(tl),i=i+1 then
            if term(tl[i].TOKEN_STRING,"(") then
                count=count+1
            elif term(tl[i].TOKEN_STRING,")") then
                count=count-1
                if count==0 then
                    index=i
                    break
                end
            end
        end
        
        # fix 'add(3,4)' bug
        if index==length_of_tl-1 then
            return false
        end

        # fix 'a() and b()' bug
        if tl[i+1]!=undefined and term(tl[i+1].TOKEN_CLASS, "relation") then
            return false
        end
        
        local tree_index=TREE_INDEX
        TREE_addNode(tree, "table_value", "")
        local tree_index2=TREE_INDEX
        TREE_addNode(TREE_getTreeAccordingToIndex(tree, tree_index), "func", "")
        func(TREE_getTreeAccordingToIndex(tree, tree_index2), tl[0:index+1])
        
        return table_value_key(TREE_getTreeAccordingToIndex(tree, tree_index),tl[index+1:length_of_tl])

    
    # expr table_value_key                //  ("He"+"llo").length()   where expr can only be  inside '()'
    else
        if term(tl[0].TOKEN_STRING, "(") then
            
           
           
            local index_of_right=-1




            local i=0
            local count=0
            for i=0,i<len(tl),i=i+1 then
                if term(tl[i].TOKEN_STRING,"(") then
                    count=count+1
                elif term(tl[0].TOKEN_STRING,")") then
                    count=count-1
                    if count==0 then
                        index_of_right=i
                        break
                    end
                end
            end            
            if index_of_right==-1 then
                return false
            else
                if index_of_right==length_of_tl-1 then
                    return false
                end
                
                # solve (a+3)^2 like problem
                if term(tl[index_of_right+1].TOKEN_CLASS, "list_table")==false or term(tl[index_of_right+1].TOKEN_STRING, ".")==false then
                    return false
                end
                local index=TREE_INDEX
                TREE_addNode(tree, "table_value", "")
               
                local index2=TREE_INDEX
                TREE_addNode(TREE_getTreeAccordingToIndex(tree, index), "expr", "")
               
                return expr(TREE_getTreeAccordingToIndex(tree, index2),tl[0:index_of_right+1]) and
                table_value_key(TREE_getTreeAccordingToIndex(tree, index), tl[index_of_right+1:length_of_tl])
            end
        end
        return false
    end
end

def table_value_key(tree, tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    local length_of_tl=len(tl)
    
    # [(string|num)value|slice]        # slice need ":"    like ':3' ':3' or '0:3'
    if length_of_tl==1 and term(tl[0].TOKEN_CLASS, "list_table") then
        # get string inside []
        local length=len(tl[0].TOKEN_STRING)
        local string_inside=tl[0].TOKEN_STRING[1:length-1]
        
        local key_tl=Walley_Lexical_Analyzie(string_inside)
        
        # check whether have :
        local index_of_colon=-1
        local i=0
        for i=0,i<len(key_tl),i=i+1 then
            if term(key_tl[i].TOKEN_STRING,":") then
                index_of_colon=i
                break
            end
        end
        
        # not slice
        if index_of_colon==-1 then
            
            local index1=TREE_INDEX
            TREE_addNode(tree, "key", "")
            
            local key_tree=TREE_init(key_tree, "key")
            value(key_tree, key_tl)
            
            TREE_addTree(TREE_getTreeAccordingToIndex(tree, index1),key_tree)
            
            return true
        # slice
        else
            local length_of_key_tl=len(key_tl)
            local index1=TREE_INDEX
            TREE_addNode(tree, "key", "")
            
            local slice_tree=TREE_init("slice")
            
            local left_tl=none
            local right_tl=none
            
            # has no left
            if index_of_colon==0 then
                left_tl=none
            else
                left_tl=key_tl[0:index_of_colon]
            end
            
            # has no right
            if index_of_colon==length_of_key_tl-1 then
                right_tl=none
            else
                right_tl=key_tl[index_of_colon+1:length_of_key_tl]
            end
            # add left
            local index_left=TREE_INDEX
            if left_tl==none then
                TREE_addNode(slice_tree, "0","num")
            else
                TREE_addNode(slice_tree, "value", "")
                value(TREE_getTreeAccordingToIndex(slice_tree, index_left), left_tl)
            end
            # add right
            local index_right=TREE_INDEX
            if right_tl==none then
                TREE_addNode(slice_tree, "its_length","special")
            else
                TREE_addNode(slice_tree, "value", "")
                value(TREE_getTreeAccordingToIndex(slice_tree, index_right), right_tl)
            end

            TREE_addTree(TREE_getTreeAccordingToIndex(tree, index1),slice_tree)
            return true
        end
        
    
    #| '.' id
    elif length_of_tl==2 and term(tl[0].TOKEN_STRING,".") and term(tl[1].TOKEN_CLASS, "id") then
        local index1=TREE_INDEX
        TREE_addNode(tree, "key", "")
        
        local key_tl=Walley_Lexical_Analyzie(toString(tl[1].TOKEN_STRING))
        local key_tree=TREE_init("key")
        value(key_tree, key_tl)
        TREE_addTree(TREE_getTreeAccordingToIndex(tree, index1),key_tree)
        
        return true
    #| '.' func
    #| '.' func table_value_key                            // behind is [] or '.'
    elif length_of_tl>=4 and term(tl[0].TOKEN_STRING,".") and term(tl[1].TOKEN_CLASS, "id") and term(tl[2].TOKEN_STRING, "(") then
        # find index_of_right )
        local index_of_right=-1
        local i=0
        local count=0
        for i=0,i<len(tl),i=i+1 then
            if term(tl[i].TOKEN_STRING,"(") then
                count=count+1
            elif term(tl[i].TOKEN_STRING,")") then
                count=count-1
                if count==0 then
                    index_of_right=i
                    break
                end
            end
        end

        if index_of_right==-1 then
            INCOMPLETE_STATEMENT=true
            return false
        end

        
        #| '.' func
        if index_of_right==length_of_tl-1 then
            local index1=TREE_INDEX
            TREE_addNode(tree, "key", "")
            
            return func(TREE_getTreeAccordingToIndex(tree, index1), tl[1:length_of_tl])
        #| '.' func table_value_key                            // behind is [] or '.'
        else
            return table_value_key(tree, tl[0:index_of_right+1]) and table_value_key(tree, tl[index_of_right+1:length_of_tl])
        end
       
    #| [(string|num)value] table_value_key
    elif length_of_tl>=2 and term(tl[0].TOKEN_CLASS, "list_table") and
             (term(tl[1].TOKEN_STRING, ".") or term(tl[1].TOKEN_CLASS, "list_table"))
             then
        return table_value_key(tree, tl[0:1]) and table_value_key(tree, tl[1:length_of_tl])
    #| [(string|num)value] '(' params ')' table_value_key
    elif length_of_tl>=3 and term(tl[0].TOKEN_CLASS, "list_table") and term(tl[1].TOKEN_STRING, "(") then       
        # find index_of_right )
        local index=-1
        local i=0
        local count=0
        for i=0,i<len(tl),i=i+1 then
            if term(tl[i].TOKEN_STRING,"(") then
                count=count+1
            elif term(tl[i].TOKEN_STRING,")") then
                count=count-1
                if count==0 then
                    index=i
                    break
                end
            end
        end

        
        # index = -1 incomplete
        if index==-1 then
            INCOMPLETE_STATEMENT=true
            return false
        end
        
        
        local func_tree=TREE_init("func")
        local tree_index=TREE_INDEX
        TREE_addNode(func_tree, "", "table_call")
        TREE_addNode(TREE_getTreeAccordingToIndex(func_tree, tree_index), "", "")
        tree_index=tree_index+1

        # get string inside []
        local length=len(tl[0].TOKEN_STRING)
        local string_inside=tl[0].TOKEN_STRING[1:length-1]
        #====================
        local string_inside_tl=Walley_Lexical_Analyzie(string_inside)
        value(TREE_getTreeAccordingToIndex(func_tree, tree_index), string_inside_tl)

        tree_index=TREE_INDEX
        TREE_addNode(func_tree, "params", "")
        if 2!=index then
            params(TREE_getTreeAccordingToIndex(func_tree, tree_index), tl[2:index])
        end

        TREE_addTree(tree, func_tree)

        if index==length_of_tl-1 then
            return true
        end
        return table_value(tree, tl[index+1:length_of_tl])

    #| '.' id table_value_key                              // behind is [] or '.'
    elif length_of_tl>=3 and term(tl[0].TOKEN_STRING, ".") and term(tl[1].TOKEN_CLASS, "id")
             and (term(tl[2].TOKEN_STRING, ".") or term(tl[2].TOKEN_CLASS, "list_table"))
             then
        return table_value_key(tree, tl[0:2]) and table_value_key(tree, tl[2:length_of_tl])
    else
        return false
    end
end


#= walley_math_parser.wy
def expr(tree, tl) then
    if INCOMPLETE_STATEMENT then
        return false
    end
    
    # expr-> expr '+' expr
    # | expr '-' expr
    # | s_term
    local length_of_tl=len(tl)
    local count_of_parenthesis=0
        
    
    local i=length_of_tl-1
    for i>=0, i=i-1 then
        if tl[i].TOKEN_STRING=="(" then
            count_of_parenthesis=count_of_parenthesis+1
            continue
        end
        if tl[i].TOKEN_STRING==")" then
            count_of_parenthesis=count_of_parenthesis-1
            continue
        end
        # expr '+' expr
        # expr '-' expr
        if count_of_parenthesis==0 and ("+"==tl[i].TOKEN_STRING or "-"==tl[i].TOKEN_STRING ) then
            local sign=tl[i].TOKEN_STRING
            
            local index_of_first_sign=i
            
            # solve x=-1 or x=+1 problem
            if index_of_first_sign==0 then
                temp_tl=[]
                local temp_token=Token_init()
                temp_token.TOKEN_STRING="0"
                temp_token.TOKEN_CLASS="num"
                temp_token.TOKEN_START=-1
                temp_token.TOKEN_END=-1
                
                temp_tl.append(temp_token)

                local a=0
                for a=0,a<len(tl),a=a+1 then
                    temp_tl.append(tl[a])
                end

                return expr(tree,temp_tl)
            end
            
            
            local tl1=tl[0:index_of_first_sign]
            local tl2=tl[index_of_first_sign+1:length_of_tl]
            tree.name=sign
            
            local index_of_expr1_node=TREE_INDEX
            TREE_addNode(tree, "expr","")
            local index_of_expr2_node=TREE_INDEX
            TREE_addNode(tree, "expr","")
            
            return expr(TREE_getTreeAccordingToIndex(tree,index_of_expr1_node), tl1) and expr(TREE_getTreeAccordingToIndex(tree,index_of_expr2_node), tl2)
        end         
    end
    # s_term
    return s_term(tree, tl) 
end

def s_term(tree,tl) then
    if INCOMPLETE_STATEMENT then
        return false
    end
    local length_of_tl=len(tl)
    local count_of_parenthesis=0    
    
    local i=length_of_tl-1
    for  i>=0, i=i-1 then
        if tl[i].TOKEN_STRING=="(" then
            count_of_parenthesis=count_of_parenthesis+1
            continue
        end

        if tl[i].TOKEN_STRING==")" then
            count_of_parenthesis=count_of_parenthesis-1
            continue
        end
    
        #    s_term "*" p_term
        # |  s_term "/" p_term
        if count_of_parenthesis==0 and ("*"==tl[i].TOKEN_STRING or "/"==tl[i].TOKEN_STRING or "%"==tl[i].TOKEN_STRING) then
            local sign=tl[i].TOKEN_STRING
            
            local index_of_first_sign=i
            local tl1=tl[0:index_of_first_sign]
            local tl2=tl[index_of_first_sign+1:length_of_tl]
            
            tree.name=sign
            
            local current_index=tree.index
            TREE_addNode(tree, "s_term","")
            TREE_addNodeAtIndex(tree, current_index, "p_term","")
            
            local index_of_node1=TREE_INDEX-2
            local index_of_node2=TREE_INDEX-1
            
            
            return s_term(TREE_getTreeAccordingToIndex(tree,index_of_node1), tl1) and p_term(TREE_getTreeAccordingToIndex(tree,index_of_node2), tl2)
        end        
    end    

    # p_term
    return p_term(tree, tl)
end

def p_term(tree, tl) then
    if INCOMPLETE_STATEMENT then
        return false
    end
    #p_term -> p_term "^" factor
    #|  factor
    local length_of_tl=len(tl)
    local count_of_parenthesis=0
    
    local i=length_of_tl-1
    for  i>=0, i=i-1 then
        if tl[i].TOKEN_STRING=="(" then
            count_of_parenthesis=count_of_parenthesis+1
            continue
        end
        if tl[i].TOKEN_STRING==")" then
            count_of_parenthesis=count_of_parenthesis-1
            continue
        end
        #   p_term "^" factor
        if count_of_parenthesis==0 and ("^"==tl[i].TOKEN_STRING or "**"==tl[i].TOKEN_STRING ) then
            local sign="^"

            local index_of_first_sign=i
            local tl1=tl[0:index_of_first_sign]
            local tl2=tl[index_of_first_sign+1:length_of_tl]
            
            tree.name=sign
            
            local current_index=tree.index
            TREE_addNode(tree, "p_term","")
            TREE_addNodeAtIndex(tree, current_index, "factor","")
            
            local index_of_node1=TREE_INDEX-2
            local index_of_node2=TREE_INDEX-1
            
            
            return p_term(TREE_getTreeAccordingToIndex(tree,index_of_node1), tl1) and factor(TREE_getTreeAccordingToIndex(tree,index_of_node2), tl2)
        end 
    end
    
    # factor
    return factor(tree, tl)
end

#factor -> value
#| (expr)
def factor(tree, tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    local length_of_tl=len(tl)
    #| (expr)
    if term(tl[0].TOKEN_STRING,"(") and term(tl[length_of_tl-1].TOKEN_STRING, ")") then
        tree.name="expr"
        tree.token_class=""
        return expr(tree, TL_subtl(tl, 1, length_of_tl-1))
    # value
    else
        return value(tree, tl)
    end
end


#= walley_assignment.wy
def assignment(tree,tl) then
    
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    
    # | 'local' var_name '=' var_value
    local is_local=false
    if term(tl[0].TOKEN_STRING, "local") then
        is_local=true
    end
    
    
    local count=0
    local count_of_equal=0
    local index_of_equal=-1
    local i=0

    for i=0,i<len(tl),i=i+1 then
        if term(tl[i].TOKEN_STRING, "(")
            or term(tl[i].TOKEN_STRING, "if")
            or term(tl[i].TOKEN_STRING, "def")
            or term(tl[i].TOKEN_STRING, "for")
            or term(tl[i].TOKEN_STRING, "while") then
            count=count+1
        elif term(tl[i].TOKEN_STRING, ")")
              or term(tl[i].TOKEN_STRING, "end") then
            count=count-1
        end
        if count==0 and tl[i].TOKEN_STRING=="=" then
            count_of_equal=count_of_equal+1
            index_of_equal=i
        end
    end
    # it is not assignment
    if count_of_equal!=1 then
        return false
    else
        
        local length_of_tl=len(tl)

        local save_TREE_INDEX=TREE_INDEX
        
        TREE_INDEX=0
        local var_name_tree=TREE_init("var_name")
        local var_name_list=[]
        # exclude local
        if is_local==true then
            var_name_list=tl[1:index_of_equal]
        else
            var_name_list=tl[0:index_of_equal]
        end
        var_name(var_name_tree, var_name_list)
        
        TREE_INDEX=0
        local var_value_tree=TREE_init("var_value")
        local var_value_list=tl[index_of_equal+1:length_of_tl]
        
        
        var_value(var_value_tree, var_value_list)
        
        TREE_INDEX=save_TREE_INDEX
        
      

        
        local var_name_num=len(var_name_tree.node_list)
              
        local i=0
        local var_name_nl=var_name_tree.node_list
        local var_value_nl=var_value_tree.node_list
        for i<var_name_num, i=i+1 then
            local index=TREE_INDEX
            TREE_addNode(tree, "=", "")
      
            #local variable
            if is_local==true then
                TREE_addNode(TREE_getTreeAccordingToIndex(tree, index),"local", "")
            end

            TREE_addTree(TREE_getTreeAccordingToIndex(tree, index), var_name_nl[i])

            if var_value_nl[i]==undefined then
                local temp_tree=TREE_init()
                temp_tree.name="none"
                temp_tree.token_class="id"
                temp_tree.node_list=[]
                TREE_addTree(TREE_getTreeAccordingToIndex(tree, index), temp_tree)
            else
                TREE_addTree(TREE_getTreeAccordingToIndex(tree, index), var_value_nl[i])
            end
            # eg x,y=12
            # then x=12
            #      y=none
        end
        
        
        return true
    end
end

def var_name(tree,tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    local index_of_comma=TL_indexOfTokenThatHasTokenString(tl, ",")
    #var_name ',' var_name
    if index_of_comma!=-1 then
        local length_of_tl=len(tl)
        local tl1=tl[0:index_of_comma]
        local tl2=tl[index_of_comma+1:length_of_tl]
     
        return var_name(tree, tl1)
        and var_name(tree, tl2)
    
    else
        local length_of_tl=len(tl)
        # id
        if length_of_tl==1 then
            if "id"==tl[0].TOKEN_CLASS then
                TREE_addNode(tree, tl[0].TOKEN_STRING,"id")
                return true    
            else
                return false
            end
        # table_value
        else
            return table_value(tree, tl)
        end
    end
    return false
end

# where ',' is the , not inside def if elif else for while
def var_value(tree,tl) then
   
    
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    local length_of_tl=len(tl)
    local index_of_comma=-1
    
    local i=0
    local count=0

    for i<length_of_tl,i=i+1 then
        if term(tl[i].TOKEN_STRING, "def")
            or term(tl[i].TOKEN_STRING, "for")
            or term(tl[i].TOKEN_STRING, "if")
            or term(tl[i].TOKEN_STRING, "while")
            or term(tl[i].TOKEN_STRING, "(") then
            count=count+1
        end
        if term(tl[i].TOKEN_STRING, "end")
            or term(tl[i].TOKEN_STRING, ")") then
            count=count-1
        end
        if count==0 and term(tl[i].TOKEN_STRING, ",") then
            index_of_comma=i
            break
        end
    end
    if count!=0 then
        INCOMPLETE_STATEMENT=true
        return false
    end
        
    #value,var_value
    if index_of_comma!=-1 then
        local tl1=tl[0:index_of_comma]
        local tl2=tl[index_of_comma+1:length_of_tl]
        
        local index_of_tl1=TREE_INDEX
        TREE_addNode(tree, "value", "")
        
        
        return value(TREE_getTreeAccordingToIndex(tree, index_of_tl1), tl1) and var_value(tree,tl2)
    
    #value
    else
        
        local index_of_tl=TREE_INDEX
        TREE_addNode(tree,"value","")

        return value(TREE_getTreeAccordingToIndex(tree, index_of_tl), tl)
    end
end


#= walley_assignment_function.wy
def func_assign(tree, tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    local length_of_tl=len(tl)
    if length_of_tl>=4 and term(tl[0].TOKEN_STRING, "def") and term(tl[1].TOKEN_STRING, "(") then
        # find )
        local index_of_right=-1
        local count=0
        local i=0
        for i<length_of_tl,i=i+1 then
            if term(tl[i].TOKEN_STRING,"(") then
                count=count+1
            end
            if term(tl[i].TOKEN_STRING,")") then
                count=count-1
                if count==0 then
                    index_of_right=i
                    break
                end
            end
        end

        if index_of_right==-1 then
            INCOMPLETE_STATEMENT=true
            console.log("INCOMPLETE_STATEMENT func_assign\n")
            process.exit(0)
        else
            TREE_addNode(tree, "def", "")
            local index=TREE_INDEX
            TREE_addNode(tree, "params", "")
            
            local params_tl=[]
            # has params
            if index_of_right!=2 then
                params_tl=tl[2:index_of_right]
            # does not have params
            else
                params_tl=[]
                local add_token=Token_init()
                add_token.TOKEN_CLASS="id"
                add_token.TOKEN_STRING="none"
                params_tl.append(add_token)
            end     
            return params(TREE_getTreeAccordingToIndex(tree, index), params_tl)
        end
    end 
    return false
end

# return_stm -> 'return' value
def return_stm(tree, tl) then
    if INCOMPLETE_STATEMENT == true then
        return false
    end

    local length_of_tl=len(tl)
    if length_of_tl>=2 and term(tl[0].TOKEN_STRING, "return") then
        local index1=TREE_INDEX
        TREE_addNode(tree, "return", "")
        local index2=TREE_INDEX
        TREE_addNode(TREE_getTreeAccordingToIndex(tree, index1), "value", "")
        
        return value(TREE_getTreeAccordingToIndex(tree, index2),tl[1:length_of_tl])
    end
    return false
end


# func_value -> func_assign walley_statements 'end'
def func_value(tree, tl) then
    if INCOMPLETE_STATEMENT == true then
        return false
    end
    local length_of_tl=len(tl)
    if term(tl[0].TOKEN_STRING, "def") and term(tl[length_of_tl-1].TOKEN_STRING, "end") then
        tree.name="func_value"
        tree.token_class=""

        local index_of_then=TL_indexOfTokenThatHasTokenString(tl, "then")
        if index_of_then==-1 then
            INCOMPLETE_STATEMENT=true
            return false
        end
        
               
       
        return func_assign(tree, tl[0:index_of_then+1])
        and walley_statements(tree, tl[index_of_then+1:length_of_tl-1])
        and end_stm(tree, tl[length_of_tl-1:length_of_tl])
    end
    return false
end

#= walley_function.wy
def params(tree, tl)then
    if INCOMPLETE_STATEMENT == true then
        return false
    end
    # has no params
    if len(tl)==0 then
        return true
    end
    local length_of_tl=len(tl)
    local index_of_comma=-1
    local count=0
    local i=0
    for i=0,i<length_of_tl,i=i+1 then
        if term(tl[i].TOKEN_STRING,"(") then
            count=count+1
            continue
        end
        if term(tl[i].TOKEN_STRING,")") then
            count=count-1
            continue
        end
        if count==0 and term(tl[i].TOKEN_STRING,",") then
            index_of_comma=i
            break
        end
    end        
    # -> assignment
    # -> value
    if index_of_comma==-1 then
        
        if assignment(tree, tl)==true then
            return true
        else
                    
            local index=TREE_INDEX
            TREE_addNode(tree, "value", "")
            
            return value(TREE_getTreeAccordingToIndex(tree, index), tl)
        end
    # -> assignment ',' params
    # -> value ',' params
    else
        
        local tl1=tl[0:index_of_comma]
        local tl2=tl[index_of_comma+1:length_of_tl]
        
        if assignment(tree, tl1)==true then
            return params(tree, tl2)
        else
            local index_of_tl1=TREE_INDEX
            TREE_addNode(tree, "value","")
            return value(TREE_getTreeAccordingToIndex(tree, index_of_tl1), tl1) and params(tree,tl2)
        end
    end
end

def func(tree, tl) then
          
    if INCOMPLETE_STATEMENT == true then
        return false
    end

    local length_of_tl=len(tl)
    # id '(' params ')'
    local index_of_left=TL_indexOfTokenThatHasTokenString(tl, "(")
    local index_of_right=-1 # find )

    if index_of_left==-1 then
        return false
    end

    local i=0
    local count=0
    for i<length_of_tl,i=i+1 then
        if term(tl[i].TOKEN_STRING,"(") then
            count=count+1
        elif term(tl[i].TOKEN_STRING,")") then
            count=count-1
            if count==0 then
                index_of_right=i
                break
            end
        end
    end

    if index_of_right==-1 then
        INCOMPLETE_STATEMENT=true
        return false
    end
    
    # false
    if index_of_right+1!=length_of_tl or index_of_left==-1 or index_of_left==0 then
        return false
    else
        local test_id=tl[0:index_of_left]
        local params_tl=[]
        # no params
        if index_of_left+1==index_of_right then   
            params_tl=[]
        # has params
        else
            params_tl=tl[index_of_left+1:index_of_right]
        end
        

        
        local length_of_test_id=len(test_id)
        if length_of_test_id!=1 or test_id[0].TOKEN_CLASS!="id" then
            return false
        end

        
        tree.name="func"
        tree.token_class=""
        TREE_addNode(tree, "", "call")
        TREE_addNode(TREE_getTreeAccordingToIndex(tree, TREE_INDEX-1),toString(test_id[0].TOKEN_STRING), "string")
        local index=TREE_INDEX
        TREE_addNode(tree, "params", "")
        
        return params(TREE_getTreeAccordingToIndex(tree, index), params_tl)
    end
end

#= walley_judge.wy

def relation(tree, tl) then
    if INCOMPLETE_STATEMENT == true then
        return false
    end
    
    local length_of_tl=len(tl)

    local i=length_of_tl-1
    local count=0
    local index_of_and_or=-1
    for i>=0, i=i-1 then
        if term(tl[i].TOKEN_STRING, "(") then
            count=count+1
            continue
        end
        if term(tl[i].TOKEN_STRING, ")") then
            count=count-1
            continue
        end
        # |relation 'and' relation
        # |relation 'or'  relation
        if count==0 and term(tl[i].TOKEN_CLASS, "relation") and tl[i].TOKEN_STRING!="not" then
            index_of_and_or=i
            
            local and_or_string=tl[i].TOKEN_STRING
            
            local tl1=tl[0:index_of_and_or]
            local tl2=tl[index_of_and_or+1:length_of_tl]
            
            local index=TREE_INDEX
            TREE_addNode(tree, and_or_string,"")
            local index1=TREE_INDEX
            TREE_addNodeAtIndex(tree,index, "relation", "")
            local index2=TREE_INDEX
            TREE_addNodeAtIndex(tree, index, "relation", "")
            
            return relation(TREE_getTreeAccordingToIndex(tree, index1), tl1) and relation(TREE_getTreeAccordingToIndex(tree, index2), tl2)            
        end
    end
    
    # |not relation
    if term(tl[0].TOKEN_STRING, "not") then
        TREE_addNode(tree, "not", "")
        local index=TREE_INDEX
        TREE_addNodeAtIndex(tree, index-1, "relation", "")
        return relation(TREE_getTreeAccordingToIndex(tree, index), tl[1:length_of_tl])
    end
    return simple_relation(tree, tl)
end


def simple_relation(tree,tl) then
    if INCOMPLETE_STATEMENT == true then
        return false
    end

    local length_of_tl=len(tl)
    
    #'(' relation ')'
    if term("(", tl[0].TOKEN_STRING) and term(")",tl[length_of_tl-1].TOKEN_STRING) then
        return relation(tree, tl[1:length_of_tl-1])
    # value judge_sign value
    # expr
    else
        tree.name="simple_relation"
        
        local index_of_judge_sign=TL_indexOfTokenThatHasTokenClass(tl, "judge_sign")
        
        # expr
        if index_of_judge_sign==-1 then
            return expr(tree, tl)
        end
        
        # value judge_sign value
        local tl1=tl[0:index_of_judge_sign]
        local tl2=tl[index_of_judge_sign+1:length_of_tl]
        
        local judge_sign=tl[index_of_judge_sign].TOKEN_STRING
        
        # swap tl1 and tl2
        # and change judge sign
        # for virtual machine
        if term(">=", judge_sign) or term(">", judge_sign) then
            local temp_tl=tl1
            tl1=tl2
            tl2=temp_tl
            if term(">=", judge_sign) then
                judge_sign="<="
            else
                judge_sign="<"
            end
        end
        
        local index=TREE_INDEX
        TREE_addNode(tree, judge_sign, "")
        
        local temp_tree=TREE_getTreeAccordingToIndex(tree, index)
        
        local index1=TREE_INDEX
        TREE_addNode(temp_tree, "value", "")
        local index2=TREE_INDEX
        TREE_addNode(temp_tree, "value", "")
        return value(TREE_getTreeAccordingToIndex(tree, index1), tl1) and value(TREE_getTreeAccordingToIndex(tree, index2), tl2)

    end    
    return false
end




#= walley_statements.wy

def if_stms(tree, tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end

    local length_of_tl=len(tl)
    
    #if_stms -> 'if' relation 'then' walley_statements 'end'
    if term(tl[0].TOKEN_STRING, "if") then
        local index_of_then=TL_indexOfTokenThatHasTokenString(tl, "then")
        if index_of_then==-1 then
            INCOMPLETE_STATEMENT=true
            return false
        end
        
        if term(tl[length_of_tl-1].TOKEN_STRING, "end") and length_of_tl>2 then
            local relation_tl=tl[1:index_of_then]
            TREE_addNode(tree, "if", "")
            local index=TREE_INDEX
            TREE_addNode(tree, "relation", "")
            return relation(TREE_getTreeAccordingToIndex(tree, index), relation_tl) and walley_statements(tree, tl[index_of_then+1:length_of_tl-1])
        
        # incomplete
        else
            INCOMPLETE_STATEMENT=true
            return false
        end
    end
    return false
end

def elif_stms(tree, tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end

    local length_of_tl=len(tl)
    # elif_stms -> 'elif' relation 'then' walley_statements 'end'
    if term(tl[0].TOKEN_STRING, "elif") then
        local index_of_then=TL_indexOfTokenThatHasTokenString(tl, "then")
        if index_of_then==-1 then
            INCOMPLETE_STATEMENT=true
            return false
        end
        if term(tl[length_of_tl-1].TOKEN_STRING, "end") and length_of_tl>2 then
            local relation_tl=tl[1:index_of_then]
            
            TREE_addNode(tree, "elif", "")
            local index=TREE_INDEX
            TREE_addNode(tree, "relation", "")
            return relation(TREE_getTreeAccordingToIndex(tree, index), relation_tl) and walley_statements(tree, tl[index_of_then+1:length_of_tl-1])
        # incomplete
        else
            INCOMPLETE_STATEMENT=true
            return false
        end
    end
    return false
end

def else_stms(tree, tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    local length_of_tl=len(tl)

    # 'else'
    if term(tl[0].TOKEN_STRING, "else") then
        if term(tl[length_of_tl-1].TOKEN_STRING, "end") then
            TREE_addNode(tree, "else", "")
            return walley_statements(tree, tl[1:length_of_tl-1])
        else
            INCOMPLETE_STATEMENT=true
            return false
        end
    end
    return false
end

def while_stms(tree, tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    local length_of_tl=len(tl)
    #'while' relation 'then'
    if term(tl[0].TOKEN_STRING, "while") then
        local index_of_then=TL_indexOfTokenThatHasTokenString(tl, "then")
        if index_of_then==-1 then
            INCOMPLETE_STATEMENT=true
            return false
        end
        
        if term(tl[length_of_tl-1].TOKEN_STRING, "end") and length_of_tl>2 then
            local relation_tl=tl[1:index_of_then]

            TREE_addNode(tree, "while", "")
            local index=TREE_INDEX
            TREE_addNode(tree, "relation", "")
            return relation(TREE_getTreeAccordingToIndex(tree, index), relation_tl)
                and walley_statements(tree, tl[index_of_then+1:length_of_tl-1])
                and end_stm(tree, tl[length_of_tl-1:length_of_tl])
        # incomplete
        else
            INCOMPLETE_STATEMENT=true
            return false
        end
    end
    return false
end

def for_stms(tree,tl) then
    if term(tl[0].TOKEN_STRING, "for")==false then
        return false
    end
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    
    local length_of_tl=len(tl)
    
    
     
    # check 
    # |  'for' id ',' id 'in' value 'then' walley_statements 'end'
    # |  'for' id        'in' value 'then' walley_statements 'end'
    # assume it is correct
    if term(tl[4].TOKEN_STRING, "in") or term(tl[2].TOKEN_STRING, "in") then
        local index_of_then=-1
        # check then index;
        local i=0
        for i<length_of_tl,i=i+1 then
            if term(tl[i].TOKEN_STRING,"then") then
                index_of_then=i
                break
            end
        end
        
        TREE_addNode(tree, "foreach", "")
        
        # for i,v in x
        # check i error
        if term(tl[1].TOKEN_CLASS, "id")==false then
            Walley_Print_Error(TL_toString(tl), "for each statements error, for i,v in value, i,v must be id", tl[1].TOKEN_START)
        end
        
        # add i
        TREE_addNode(tree, tl[1].TOKEN_STRING, "foreach_index")
        
        if term(tl[2].TOKEN_STRING, ",") then
            # check v error
            if term(tl[3].TOKEN_CLASS, "id")==false then
                Walley_Print_Error(TL_toString(tl), "for each statements error, for i,v in value, i,v must be id", tl[3].TOKEN_START)
            end
            
            # add v
            TREE_addNode(tree, tl[3].TOKEN_STRING, "foreach_value")
            #tl=tl->next->next->next->next->next # value
            
            # add in value
            local index=TREE_INDEX
            TREE_addNode(tree, "", "foreach_in")
            TREE_addNode(TREE_getTreeAccordingToIndex(tree, index), "value", "")
            index=index+1
            value(TREE_getTreeAccordingToIndex(tree, index),tl[5:index_of_then])
        else
            # add v
            TREE_addNode(tree, "", "foreach_value")
            #tl=tl->next->next->next; // value
            
            # add in value
            local index=TREE_INDEX
            TREE_addNode(tree, "", "foreach_in")
            TREE_addNode(TREE_getTreeAccordingToIndex(tree, index), "value", "")
            index=index+1
            value(TREE_getTreeAccordingToIndex(tree, index), tl[3:index_of_then])
        end
        
        return walley_statements(tree, tl[index_of_then+1:length_of_tl-1])
         and end_stm(tree, tl[length_of_tl-1:length_of_tl])
    end
    
    local num_of_comma=0
    local count_of_p=0 # count of ()

    local index_of_comma=[-1,-1,-1]
        
    local index=0
    local i=0
    
    local index_of_then=-1
    
    for i<length_of_tl,i=i+1 then
        if term(tl[i].TOKEN_STRING,"then") then
            index_of_then=i
            break
        end

        if term(tl[i].TOKEN_STRING,"(") then
            count_of_p=count_of_p+1
            continue
        end

        if term(tl[i].TOKEN_STRING,")") then
            count_of_p=count_of_p-1
            continue
        end

        if count_of_p==0 and term(tl[i].TOKEN_STRING,",") then
            if index<2 then
                index_of_comma[index]=i
                index=index+1
            end
            num_of_comma=num_of_comma+1
        end
    end
    
    # incomplete
    if index_of_then==-1 or term(tl[length_of_tl-1].TOKEN_STRING, "end")==false then
        INCOMPLETE_STATEMENT=true
        return false
    end
    
    if length_of_tl!=2
        and num_of_comma!=0
        and num_of_comma<=2
        then
        #|  'for' simple_relation ',' assignment 'then' walley_statements 'end'
        if num_of_comma==1 then
            local simple_relation_tl=tl[1:index_of_comma[0]]
            local assignment_tl=tl[index_of_comma[0]+1:index_of_then]
        
            TREE_addNode(tree, "for", "")
            local index_of_sr=TREE_INDEX
            TREE_addNode(tree, "simple_relation", "")
            local index_of_a=TREE_INDEX
            TREE_addNode(tree, "assignment", "")
            
            return simple_relation(TREE_getTreeAccordingToIndex(tree, index_of_sr), simple_relation_tl)
            and assignment(TREE_getTreeAccordingToIndex(tree, index_of_a), assignment_tl)
            and walley_statements(tree, tl[index_of_then+1:length_of_tl-1])
            and end_stm(tree, tl[length_of_tl-1:length_of_tl])
        
        #|  'for' ',' simple_relation ',' assignment 'then' walley_statements 'end'
        #|  'for' assignment ',' simple_relation ',' assignment 'then' walley_statements 'end'
        else
            #|  'for' ',' simple_relation ',' assignment 'then' walley_statements 'end'
            if term(tl[1].TOKEN_STRING, ",") then
                local simple_relation_tl=tl[2:index_of_comma[1]]
                local assignment_tl=tl[index_of_comma[1]+1:index_of_then]
                
                TREE_addNode(tree, "for", "")
                local index_of_sr=TREE_INDEX
                TREE_addNode(tree, "simple_relation", "")
                local index_of_a=TREE_INDEX
                TREE_addNode(tree, "assignment", "")
                
                return simple_relation(TREE_getTreeAccordingToIndex(tree, index_of_sr), simple_relation_tl)
                and assignment(TREE_getTreeAccordingToIndex(tree, index_of_a), assignment_tl)
                and walley_statements(tree, tl[index_of_then+1:length_of_tl-1])
                and end_stm(tree, tl[length_of_tl-1:length_of_tl])
            
            #|  'for' assignment ',' simple_relation ',' assignment 'then' walley_statements 'end'

            else
                local assignment_tl1=tl[1:index_of_comma[0]]
                local simple_relation_tl=tl[index_of_comma[0]+1:index_of_comma[1]]
                local assignment_tl2=tl[index_of_comma[1]+1:index_of_then]
                
                TREE_addNode(tree, "for","")
                local index_of_a_tl1=TREE_INDEX
                TREE_addNode(tree, "assignment", "")
                local index_of_sr=TREE_INDEX
                TREE_addNode(tree, "simple_relation","")
                local index_of_a_tl2=TREE_INDEX
                TREE_addNode(tree, "assignment","")
                
                return assignment(TREE_getTreeAccordingToIndex(tree, index_of_a_tl1), assignment_tl1)
                    and simple_relation(TREE_getTreeAccordingToIndex(tree, index_of_sr),simple_relation_tl)
                    and assignment(TREE_getTreeAccordingToIndex(tree, index_of_a_tl2),assignment_tl2)
                    and walley_statements(tree, tl[index_of_then+1:length_of_tl-1])
                    and end_stm(tree, tl[length_of_tl-1:length_of_tl])
            end
        end
    end
    return false
end

def func_stms(tree, tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    local length_of_tl=len(tl)
    #'def' func 'then'
    if term(tl[0].TOKEN_STRING, "def") then
        if length_of_tl>2 and term(tl[length_of_tl-1].TOKEN_STRING, "then") then
            TREE_addNode(tree, "def", "")
            
            local func_tl=tl[1:length_of_tl-1]
            
            local index=TREE_INDEX
            TREE_addNode(tree, "func","")
            return func(TREE_getTreeAccordingToIndex(tree, index), func_tl)
             and end_stm(tree, tl[length_of_tl-1:length_of_tl])
        # incomplete 
        else
            INCOMPLETE_STATEMENT=true
            return false
        end
    end
    return false
end



def end_stm(tree, tl) then
    
    if INCOMPLETE_STATEMENT==true then
        return false
    end

    if len(tl)==1 and term(tl[0].TOKEN_CLASS, "end") then
        TREE_addNode(tree, "end","")
        return true
    end
    return false
end

# def_stms -> 'def' func_name_stm '(' params ')' 'then' walley_statements 'end'
def def_stms(tree, tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    local length_of_tl=len(tl)

    if term(tl[0].TOKEN_STRING, "def") and term(tl[1].TOKEN_STRING, "(")==false then
        local index_of_then=TL_indexOfTokenThatHasTokenString(tl, "then")
        local index_of_left_bracket=TL_indexOfTokenThatHasTokenString(tl, "(")
        if index_of_then==-1 then
            INCOMPLETE_STATEMENT=true
            return false
        end
        
        if term(tl[length_of_tl-1].TOKEN_STRING, "end")==false then
            INCOMPLETE_STATEMENT=true
            return false
        end
        
        local new_tl=[]
        local begin=1

        local i=0
        for i<index_of_left_bracket,i=i+1 then
            if i>=begin then
                new_tl.append(tl[i])
            end
        end

        local add_token=Token_init()
        add_token.TOKEN_STRING="="
        add_token.TOKEN_CLASS="assignment_operator"
        new_tl.append(add_token)
        
        i=0
        for i=0, i<length_of_tl, i=i+1 then
            if i>=begin and i<index_of_left_bracket then
                continue
            end
            new_tl.append(tl[i])
        end
        
        return assignment(tree, new_tl)
    else
        return false
    end
end

#self_operator_stm
# x++
# var_name self_operator
def self_operator_stm(tree,tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    local length_of_tl=len(tl)
    if tl[length_of_tl-1].TOKEN_CLASS=="self_operator" then
        local index = TREE_INDEX
        TREE_addNode(tree,"self_operator_stm","")

        local valid_var_name=var_name(TREE_getTreeAccordingToIndex(tree, index), tl.slice(0, length_of_tl - 1))
        if valid_var_name==true then
            TREE_addNode(TREE_getTreeAccordingToIndex(tree, index), tl[length_of_tl - 1]["TOKEN_STRING"],"self_operator")
            return true
        else
            console.log("Error.. invalid self operation\n")
            process.exit(0)
        end
    else
        return false
    end
end

# x += 12
# x              +=                  12
# var_name self_assignment_operator value

def self_assignment_stm(tree,tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    local length_of_tl=len(tl)
    local index_of_self_assignment_operator=TL_indexOfTokenThatHasTokenClass(tl,"self_assignment")
    if index_of_self_assignment_operator==-1 then
        return false
    else
        local var_name_tl = tl[0:index_of_self_assignment_operator]
        local var_value_tl = tl[index_of_self_assignment_operator+1:length_of_tl]

        local index=TREE_INDEX
        TREE_addNode(tree,"self_assignment_stm","")
        local valid_var_name=var_name(TREE_getTreeAccordingToIndex(tree, index), var_name_tl)
        if valid_var_name==false then
            return false
        end

        TREE_addNode(TREE_getTreeAccordingToIndex(tree,index),tl[index_of_self_assignment_operator].TOKEN_STRING,"self_assignment")

        local index2=TREE_INDEX
        TREE_addNode(TREE_getTreeAccordingToIndex(tree, index),"","value")
        local valid_var_value = value(TREE_getTreeAccordingToIndex(tree, index2), var_value_tl)
        
        if valid_var_value==false then
            return false
        else
            return true
        end
    end

end

# import "hello.wy"
# import import_file
# only support 'import string' now
def import_stm(tree,tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    if tl[0].TOKEN_CLASS=="import" then
        TREE_addNode(tree,"import","")
        local index=TREE_INDEX
        local length_of_tl=len(tl)
        if length_of_tl!=2 or tl[1].TOKEN_CLASS!="string" then
            console.log("Error.. only support import statements like 'import \" hello.wy \"'")
            process.exit(0)
        end
        TREE_addNode(tree,tl[1].TOKEN_STRING,"import_file")
        return true
    else
        return false
    end    
end
def statements(tree, tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    return import_stm(tree,tl)
        or self_operator_stm(tree,tl)
        or self_assignment_stm(tree,tl)
        or return_stm(tree, tl)
        or if_stms(tree, tl)
        or elif_stms(tree, tl)
        or else_stms(tree, tl)
        or while_stms(tree, tl)
        or for_stms(tree, tl)
        or def_stms(tree, tl)
        or end_stm(tree, tl)
        or assignment(tree, tl)
        or value(tree, tl)
end

#walley_statements ->
#| statements, statements        // use sentences_separation
def walley_statements(tree, tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
   
    local temp_tl=[val=[]]
    local begin=[val=0]
    
    while sentences_separation(tl, temp_tl, begin)==true then
        if INCOMPLETE_STATEMENT==true then
            return false
        end
        
        local index=TREE_INDEX
        TREE_addNode(tree, "statements", "")
        
        if statements(TREE_getTreeAccordingToIndex(tree, index), temp_tl.val)==false then
            console.log("Walley Statements Parse Error\n")
            return false
        end
    end
    if INCOMPLETE_STATEMENT==true then
            return false
    end
    return true
end

# output_tl=[val=[]] 
# begin=[val=0]
# need to use .val
def sentences_separation(tl, output_tl,begin) then
    local length_of_tl=len(tl)
    
    if begin.val>=length_of_tl then
        return false
    end
    
    i=begin.val

    for  i<length_of_tl, i=i+1 then
        
        # x=1 y=2 ->
        # x=1
        # y=2
        if i<length_of_tl-1 and (term(tl[i].TOKEN_CLASS, "num") or term(tl[i].TOKEN_CLASS, "string") or term(tl[i].TOKEN_CLASS, "id") or term(tl[i].TOKEN_CLASS, "list_table") or term(tl[i].TOKEN_STRING, ")") or term(tl[i].TOKEN_CLASS,"self_operator"))
            and (term(tl[1+i].TOKEN_CLASS, "id") or term(tl[1+i].TOKEN_CLASS, "num")
                or term(tl[i+1].TOKEN_CLASS, "return") or term(tl[i+1].TOKEN_STRING, "continue") or term(tl[1+i].TOKEN_STRING, "break") or term(tl[1+i].TOKEN_CLASS, "local") or term(tl[i+1].TOKEN_CLASS,"import")) then
            local end_index=i+1
            local ahead_tl=tl[begin.val:end_index]
            output_tl.val=ahead_tl
            begin.val=end_index
            return true
        end
        
        # find end corresponding to that def
        # def (num1,num2) return num1+num2 end
        # then set i to that end
        if term(tl[i].TOKEN_STRING, "def") or
            term(tl[i].TOKEN_STRING, "for") or 
            term(tl[i].TOKEN_STRING, "while") then
            
            # return ahead Token_List
            if begin.val!=i then
                if term(tl[i].TOKEN_STRING, "def") and term(tl[i+1].TOKEN_STRING, "(") then
                   #nothing 
                   console.log("")
                else
                    local end_index=i
                    local ahead_tl=tl[begin.val:end_index]
                
                    begin.val=end_index
                    output_tl.val=ahead_tl
                    return true
                end
            end
            
            local count=0
            for i<length_of_tl, i=i+1 then
                if term(tl[i].TOKEN_STRING, "def")
                    or term(tl[i].TOKEN_STRING, "for")
                    or term(tl[i].TOKEN_STRING, "if")
                    or term(tl[i].TOKEN_STRING, "while") then
                    count=count+1
                end
                if term(tl[i].TOKEN_STRING, "end") then
                    count=count-1
                end
                if count==0 then
                    break
                end
            end
            
            if count==0 then
                local end_index=i+1
                local ahead_tl=tl[begin.val:end_index]
                output_tl.val=ahead_tl
                begin.val=end_index
                return true
            else
                INCOMPLETE_STATEMENT=true
                return false
            end
        end
        
        
        # find 'end' or 'elif' or 'else'
        # if no 'end' found--- incomplete
        # if find 'elif' or 'else', add 'end' manually
        if term(tl[i].TOKEN_STRING, "if") then 
            # return ahead Token_List
            if begin.val!=i then
                
                local end_index=i
                local ahead_tl=tl[begin.val:end_index]
                begin.val=end_index
                output_tl.val=ahead_tl
                return true
            end
            
            
            local count_of_if=0
            local count_of_end=0
            for  i<length_of_tl,i=i+1 then
                if term(tl[i].TOKEN_STRING, "if")
                or term(tl[i].TOKEN_STRING, "def")
                or term(tl[i].TOKEN_STRING, "while")
                or term(tl[i].TOKEN_STRING, "for") then
                    count_of_if=count_of_if+1
                    count_of_end=count_of_end+1
                end
                
                if term(tl[i].TOKEN_STRING, "end") then
                    count_of_if=count_of_if-1
                    count_of_end=count_of_end-1
                end
                
                if count_of_end==0 then
                    break
                end
                
                if count_of_if==1 and
                    (term(tl[i].TOKEN_STRING, "elif")
                     or term(tl[i].TOKEN_STRING, "else"))
                    then
                    
                    local end_index=i
                    local ahead_tl=tl[begin.val:end_index]
                    local end_token=Token_init()
                    end_token.TOKEN_STRING="end"
                    end_token.TOKEN_CLASS="end"
                    ahead_tl.append(end_token)
                    
                    begin.val=end_index
                    output_tl.val=ahead_tl
                    
                    return true
                end
            end
            
            # incomplete
            if count_of_if!=count_of_end or count_of_if!=0 then
                INCOMPLETE_STATEMENT=true
                return false
            # complete
            #~
             eg: 
             if x>0 then
                if x>3 then
                    x=12
                end
             end
             
            ~# 
            else
                local end_index=i+1
                local ahead_tl=tl[begin.val:end_index]
                
                begin.val=end_index-1
                output_tl.val=ahead_tl
                return true
            end
        end
        
        # elif
        if term(tl[i].TOKEN_STRING, "elif") then
            local count_of_if=0
            local count_of_end=0
            local temp_i=i
            for  i<length_of_tl, i=i+1 then
                if term(tl[i].TOKEN_STRING, "if")
                or term(tl[i].TOKEN_STRING, "def")
                or term(tl[i].TOKEN_STRING, "while")
                or term(tl[i].TOKEN_STRING, "for") then
                    count_of_if=count_of_if+1
                    count_of_end=count_of_end+1
                end
                
                if term(tl[i].TOKEN_STRING, "end") then
                    count_of_end=count_of_end-1
                    count_of_if=count_of_if-1
                end
                
                # find elif or else
                if count_of_if==0 and i!=temp_i and
                    ( term(tl[i].TOKEN_STRING, "elif") or
                     term(tl[i].TOKEN_STRING, "else")
                     )
                    then
                    local end_index=i
                    local ahead_tl=tl[begin.val:end_index]
                    
                    local end_token=Token_init()
                    end_token.TOKEN_STRING="end"
                    end_token.TOKEN_CLASS="end"
                    ahead_tl.append(end_token)
                    
                    begin.val=end_index
                    output_tl.val=ahead_tl
                    return true
                end
                # elif then ... end
                if count_of_end==-1 and count_of_if==-1 then
                    local end_index=i+1
                    local ahead_tl=tl[begin.val:end_index]
                    
                    begin.val=end_index-1
                    output_tl.val=ahead_tl
                    return true
                end
            end
            
            # incomplete
            INCOMPLETE_STATEMENT=true
            return false
    
            
        end
        
        # else
        if term(tl[i].TOKEN_STRING, "else") then
            local count_of_if=0
            local count_of_end=0
            local temp_i=i
            for i<length_of_tl,i=i+1 then
                if term(tl[i].TOKEN_STRING, "if")
                or term(tl[i].TOKEN_STRING, "def")
                or term(tl[i].TOKEN_STRING, "while")
                or term(tl[i].TOKEN_STRING, "for") then
                    count_of_if=count_of_if+1
                    count_of_end=count_of_end+1
                end
                if term(tl[i].TOKEN_STRING, "end") then
                    count_of_if=count_of_if-1
                    count_of_end=count_of_end-1
                end
                
                #error
                if count_of_if==0 and i!=temp_i and (term(tl[i].TOKEN_STRING, "elif") or term(tl[i].TOKEN_STRING, "else")) then
                    Walley_Print_Error(TL_toString(temp_tl), "elif or else statements error", tl[i].TOKEN_START)
                end
                
                # finish else
                if count_of_end==-1 then
                    local end_index=i+1
                    local ahead_tl=tl[begin.val:end_index]
                    
                    begin.val=end_index-1
                    output_tl.val=ahead_tl
                    return true

                end
            end
            
            INCOMPLETE_STATEMENT=true
            return false
        end
    
        # end->
        # end
        if term(tl[i].TOKEN_STRING, "end") then
            local end_index=i
            if begin.val<i then
                local ahead_tl=tl[begin.val:end_index]
                
                begin.val=end_index
                output_tl.val=ahead_tl
                return true
            
            else
                begin.val=end_index
            end
            
            
            end_index=i+1
            local ahead_tl=tl[begin.val:end_index]
            
            begin.val=end_index
            output_tl.val=ahead_tl
            return true
        end
    end
    if begin.val<length_of_tl then
        local ahead_tl=tl[begin.val:length_of_tl]
       
        begin.val=length_of_tl
        output_tl.val=ahead_tl
        return true
    end
    
    return false
end

#= walley_parser.wy

# Generate AST
def parser(tl) then
    # reset TREE_INDEX value
    TREE_INDEX=0
    
    local output_tree=TREE_init("walley_statements")
    
    if len(tl)==0 then
        return output_tree
    end

    if walley_statements(output_tree, tl)==false and INCOMPLETE_STATEMENT==false then
        console.log("Fail to parse statements\n")
    end

    #TREE_print(output_tree)
    
     
    return output_tree
end


#= walley_calculation.wy
def ism_operator(input_str) then
    if term(input_str, "+") 
        or term(input_str, "-")
        or term(input_str, "*")
        or term(input_str, "/")
        or term(input_str,"^")
        or term(input_str, "%") then
        return true
    end
    return false
end

def Walley_Calculation(value1, value2, sign) then
    # number calculation
    if value1[0]!="\"" and value2[0]!="\"" then
        if sign=="^" then
            return eval("Math.pow("+value1+","+value2+")")
        end
        return eval(value1+sign+value2)
    # string or number calculation
    else
        local value1IsString=false
        local value2IsString=false
        if value1[0]=="\"" then
            value1=value1[1:len(value1)-1]
            value1IsString=true
        end

        if value2[0]=="\"" then
            value2=value2[1:len(value2)-1]
            value2IsString=true
        end

        if sign[0]=="+" then
            local output_str="\""+value1+value2+"\""
            return output_str
        elif sign[0]=="*" then
            if value1IsString==true and value2IsString==true then
                console.log("Error.. Can not multiply two string %s and %s\n",value1,value2)
                process.exit(0)
            else
                local num=0
                local mult_str=""
                if value1IsString==true then
                    mult_str=value1
                    num=parseInt(value2)
                else
                    mult_str=value2
                    num=parseInt(value1)
                end
                
                local output_str="\""
                local i=0

                for i<num, i=i+1 then
                    output_str=output_str+mult_str
                end
                output_str=output_str+"\""
                return output_str
            end
        else
            console.log("Error.. Sign %s can not be used for string calculation for %s and %s\n",sign,value1,value2)
            process.exit(0)
        end
    end
end



#= walley_cg_js.wy
def isString(input_str) then
    if input_str[0]!="\"" or input_str[input_str.length-1]!="\"" then
        return false
    end
    local count=0
    local i=0
    local length=input_str.length
    for i<length, i=i+1 then
        if input_str[i]=="\"" then
            count=count+1
        end
    end
    if count!=2 then
        return false
    else
        return true
    end

end

js_isTableValue=false
# compile to javascript
def Code_Generation_2_Javascript(sl,tree)then
    if term(tree.token_class,"id") then
        # continue
        if term(tree.name, "continue") then
            return "continue;"
        end
        
        if term(tree.name, "break") then
            return "break;"
        end
        
        # change 'none' to 'null'
        if term(tree.name, "none") then
            return "null"
        end
        return tree.name

    elif term(tree.name, "walley_statements") then
        
        local nl=tree.node_list
        
        local output_str=""
        
        local i=0
        local length_of_nl=len(nl)
        for i=0,i<length_of_nl,i=i+1 then
            local temp_str=Code_Generation_2_Javascript(sl,nl[i])

            if len(temp_str)!=0 then
                output_str=output_str+temp_str
                if output_str[len(output_str)-1]!="\n" then
                    if output_str[len(output_str)-1]!=";" then
                        output_str=output_str+";\n"
                    else
                        output_str=output_str+"\n"
                    end
                end
            end
        end 
        
        return output_str
    
    elif term(tree.name, "statements") then
        nl=tree.node_list
        
        if term(nl[0].name, "if") then
            #~
             ( statements
                ( if)
                ( simple_relation
                    ( <(num 4)(id x))
                )
                ( statements
                    ( =(id x)(num 12))
                )
             )
             ( statements( end))
             
             ( statements
                ( if)
                ( relation
                    ( and
                        ( simple_relation( <(num 4)(id x)))
                        ( simple_relation( <(id x)(num 12))))
                )
                ( statements( =(id x)(num 12))))
             ( statements( end))
             ~#
            
            local append_str="if ("
            local judge_str=Code_Generation_2_Javascript(sl, nl[1])
            
            append_str=append_str+judge_str
            append_str=append_str+"){\n"
            
            
            local i=2
            local length_of_nl=len(nl)
            local output_str=""
            for i=2,i<length_of_nl,i=i+1 then
                local temp_str=Code_Generation_2_Javascript(sl,nl[i])

                if len(temp_str)!=0 then
                    output_str=output_str+temp_str
                    if output_str[len(output_str)-1]!="\n" then
                        if output_str[len(output_str)-1]!=";" then
                            output_str=output_str+";\n"
                        else
                            output_str=output_str+"\n"
                        end
                    end
                end
            end
            
            append_str=append_str+output_str
            return append_str

        elif term(nl[0].name, "elif") then
            
            local append_str="}\nelse if ("
            local judge_str=Code_Generation_2_Javascript(sl, nl[1])
        
            append_str=append_str+judge_str
            append_str=append_str+"){\n"
            
                        
            local i=2
            local length_of_nl=len(nl)
            local output_str=""
            for i=2,i<length_of_nl,i=i+1 then
                local temp_str=Code_Generation_2_Javascript(sl,nl[i])

                if len(temp_str)!=0 then
                    output_str=output_str+temp_str
                    if output_str[len(output_str)-1]!="\n" then
                        if output_str[len(output_str)-1]!=";" then
                            output_str=output_str+";\n"
                        else
                            output_str=output_str+"\n"
                        end
                    end
                end
            end
            
            append_str=append_str+output_str
            return append_str

        elif term(nl[0].name, "else") then
            
            local append_str="}\nelse{\n"
            
            local i=1
            local length_of_nl=len(nl)
            local output_str=""
            for i=1,i<length_of_nl,i=i+1 then
                local temp_str=Code_Generation_2_Javascript(sl,nl[i])

                if len(temp_str)!=0 then
                    output_str=output_str+temp_str
                    if output_str[len(output_str)-1]!="\n" then
                        if output_str[len(output_str)-1]!=";" then
                            output_str=output_str+";\n"
                        else
                            output_str=output_str+"\n"
                        end
                    end
                end
            end
            
            append_str=append_str+output_str
            return append_str

        elif term(nl[0].name, "while") then
            #~
             ( walley_statements
                ( statements
                    ( while)
                    ( simple_relation( <(id x)(num 10)))
                    ( statements( =(id x)(num 12)))
                    ( end)
                )
            )
             ~#
            local append_str="while ("
            local judge_str=Code_Generation_2_Javascript(sl, nl[1])
            
            
            append_str=append_str+judge_str
            append_str=append_str+"){\n"
            
            
            local i=2
            local length_of_nl=len(nl)
            local output_str=""
            for i<length_of_nl,i=i+1 then
                local temp_str=Code_Generation_2_Javascript(sl,nl[i])

                if len(temp_str)!=0 then
                    output_str=output_str+temp_str
                    if output_str[len(output_str)-1]!="\n" then
                        if output_str[len(output_str)-1]!=";" then
                            output_str=output_str+";\n"
                        else
                            output_str=output_str+"\n"
                        end
                    end
                end
            end
            
            append_str=append_str+output_str
            return append_str

        elif term(nl[0].name,"for") then
            #~
             # for i=0,i<10,i=i+1 then i=2 end
            ( walley_statements
                ( statements
                    ( for)
                    ( assignment
                        ( =(id i)(num 0))
                    )
                    ( simple_relation
                        ( <(id i)(num 10))
                    )
                    ( assignment( =(id i)( +(id i)(num 1))))
                    ( statements( =(id i)(num 2)))
                    ( end)
                )
             )
             ~#
            local append_str="for ("
            
            local nl_index=1
            if term(nl[1].name, "assignment") then
                append_str=append_str+Code_Generation_2_Javascript(sl, nl[1].node_list[0])
                append_str=append_str+";"
                nl_index=2
            else
                append_str=append_str+";"
                nl_index=1
            end
            
            # nl now is relation
            local judge_str=Code_Generation_2_Javascript(sl, nl[nl_index])
            
            append_str=append_str+judge_str
            append_str=append_str+";"

            nl_index=nl_index+1
            
            if term(nl[nl_index].name, "assignment") then
                append_str=append_str+Code_Generation_2_Javascript(sl, nl[nl_index].node_list[0])
                nl_index=nl_index+1
            end
            append_str=append_str+"){\n"
            
            local output_str=""
            local i=nl_index
            local length_of_nl=len(nl)

            for i<length_of_nl-1,i=i+1 then
                local temp_str=Code_Generation_2_Javascript(sl,nl[i])
                if len(temp_str)!=0 then
                    output_str=output_str+temp_str
                    if output_str[len(output_str)-1]!="\n" then
                        if output_str[len(output_str)-1]!=";" then
                            output_str=output_str+";\n"
                        else
                            output_str=output_str+"\n"
                        end
                    end
                end  
            end


            append_str=append_str+output_str

            append_str=append_str+"\n}"
            return append_str
           
        elif term(nl[0].name, "foreach") then
            #~
            for(var i in x){
                // add this 
                if(x.hasOwnProperty(i))
                    {
                    

                    }
            }

             ( walley_statements
                ( statements
                    ( foreach)
                    (foreach_index i)
                    (foreach_value v)
                    (foreach_in 
                        ( +(string "Hello")(num 13))
                    )
                    ( statements( =(id i)(num 2)))
                    ( end)
                )
             )
         
            ~#
            local append_str="for("
            # for i,v in x
            # get i
            local foreach_index=nl[1].name
            append_str=append_str+foreach_index
            append_str=append_str+ " in "
            
            
            local has_v=true
            if term(nl[2].name, "") then
                has_v=false
            end
            
            local foreach_in_value=Code_Generation_2_Javascript(sl, nl[3].node_list[0])
            # append in value
            append_str=append_str+foreach_in_value
            append_str=append_str+"){\n"

            # solve enumerable problem
            append_str=append_str+"if(("+foreach_in_value+").hasOwnProperty("+foreach_index+")){\n"
            
            
            if has_v==true then
                
                local value_var_name=nl[2].name
                append_str=append_str+value_var_name+"="
                
                local in_value="("+foreach_in_value+")"
                local in_value_and_key=in_value+"["+foreach_index+"]"
                
                append_str=append_str + in_value_and_key
                append_str=append_str + ";\n"
            end
            
            local i=4
            local length_of_nl=len(nl)
            local output_str=""

            for i<length_of_nl,i=i+1 then
                local temp_str=Code_Generation_2_Javascript(sl,nl[i])

                if len(temp_str)!=0 then
                    output_str=output_str+temp_str
                    if output_str[len(output_str)-1]!="\n" then
                        if output_str[len(output_str)-1]!=";" then
                            output_str=output_str+";\n"
                        else
                            output_str=output_str+"\n"
                        end
                    end
                end
            end
            
            append_str=append_str+output_str
            append_str=append_str+"};\n"
            return append_str

        # import file_name
        elif nl[0].name=="import" then
            local import_file=nl[1].name
            import_file=import_file.slice(1,import_file.length-1)

            local fs=require("fs")
            local content_in_import_file=fs.readFileSync(import_file,"utf8")


            local output_str=exports.Code_Generation(content_in_import_file)
            if exports.INCOMPLETE_STATEMENT==true then
                console.log("Error.. statements in file %s is incomplete\n",import_file)
                process.exit(0)
            end
            return output_str
        
        else
            local append_str=""
            local i=0
            local length_of_nl=len(nl)
            local output_str=""
            for i<length_of_nl,i=i+1 then
                local temp_str=Code_Generation_2_Javascript(sl,nl[i])

                if len(temp_str)!=0 then
                    output_str=output_str+temp_str
                    if output_str[len(output_str)-1]!="\n" then
                        if output_str[len(output_str)-1]!=";" then
                            output_str=output_str+";\n"
                        else
                            output_str=output_str+"\n"
                        end
                    end
                end
            end
            
            append_str=append_str+output_str
            return append_str
        end
        return ""
    

    # this place has problem
    elif term(tree.name, "relation") then
        local judge_tree=tree.node_list[0]
        #<(num 4)(id x)
        
        local left_tree=judge_tree.node_list[0]
        local right_tree=judge_tree.node_list[1]
        
        local left_str=Code_Generation_2_Javascript(sl, left_tree)
        local right_str=Code_Generation_2_Javascript(sl, right_tree)
        local append_str=left_str
        local relationship=none
        if term(judge_tree.name, "and") then
            relationship=" && "
        
        else
            relationship=" || "
        end
        append_str=append_str+relationship
        append_str=append_str+right_str
        
        append_str="("+append_str+")"
        
        return append_str
    
    
    # this place has problem
    elif term(tree.name, "simple_relation") then
        local judge_tree=tree.node_list[0]
        #<(num 4)(id x)
        
        local left_tree=judge_tree.node_list[0]
        local right_tree=judge_tree.node_list[1]
        
        local left_str=Code_Generation_2_Javascript(sl, left_tree)
        local right_str=Code_Generation_2_Javascript(sl, right_tree)
        local append_str=left_str
        
        local judge_sign=judge_tree.name
        if term(judge_sign, "==") then
            judge_sign="==="
        
        elif term(judge_sign, "!=") then
            judge_sign="!=="
        end
        
        append_str=append_str+judge_sign
        append_str=append_str+right_str
        
        return append_str
    
    # x++ or x--
    elif term(tree.name,"self_operator_stm") then
        local var_name = Code_Generation_2_Javascript(sl, tree.node_list[0])
        return var_name+tree.node_list[1].name
    # x+=1
    elif term(tree.name,"self_assignment_stm") then
        local var_name = Code_Generation_2_Javascript(sl, tree.node_list[0])
        local append_string=var_name
        append_string=append_string + tree.node_list[1].name
        local var_value=Code_Generation_2_Javascript(sl,tree.node_list[2])
        append_string=append_string+var_value
        return append_string
     
    # append
    elif term(tree.name,"=") then
        local  is_local=false
        local append_string=""
        
        local nl=tree.node_list
        local var_name_tree=nl[0]
        if term(var_name_tree.name, "local") then
            is_local=true
            var_name_tree=nl[1]
        end

        local var_value_tree=none
        if is_local==true then
            var_value_tree=nl[2]
        else
            var_value_tree=nl[1]
        end
        
        local var_name=Code_Generation_2_Javascript(sl, var_name_tree)
        
        append_string=var_name
        if is_local ==true then
            append_string="var " + append_string
        end
        
        append_string=append_string + "="
                
        
        local var_value=Code_Generation_2_Javascript(sl, var_value_tree)
        
        append_string=append_string + var_value        
                
        return append_string
        
    
    elif term(tree.name, "func_value") then
        local append_string="function("
        
        local param_str=Code_Generation_2_Javascript(sl, tree.node_list[1])
        
        append_string=append_string+param_str
        append_string=append_string+"){\n"
        
        #( func_value( def)( params(id none))( statements( =(id a)(num 12)))( end))
        #~
         ( func_value
            ( def)
            ( params(id none))
            ( statements( =(id a)(num 12)))
            ( end)
         )
         
         
         ~#
        
        local nl=tree.node_list
        local i=2
        local output_str=""
        local length_of_nl=len(nl)


        for i<length_of_nl-1,i=i+1 then
            local temp_str=Code_Generation_2_Javascript(sl,nl[i])
            if len(temp_str)!=0 then
                output_str=output_str+temp_str
                if output_str[len(output_str)-1]!="\n" then
                    if output_str[len(output_str)-1]!=";" then
                        output_str=output_str+";\n"
                    else
                        output_str=output_str+"\n"
                    end
                end
            end
        end

        append_string=append_string+output_str
        
        append_string=append_string+" }"
        return append_string
    
    #~
     (table [1,2,3]
        ( table_expr
            ( key(num 0))
            (num 1)
        )
        ( table_expr
            ( key(num 1))
            (num 2))
        ( table_expr
            ( key(num 2))
            (num 3)
        )
     )
        Convert Walley Table to JS array
    ~#
    elif term(tree.token_class, "table") then
        local append_str="{"
        local nl=tree.node_list

        local i=0
        local length_of_nl=len(nl)
        for i=0,i<length_of_nl,i=i+1 then
            local temp_str=Code_Generation_2_Javascript(sl,nl[i])
            append_str=append_str+temp_str
            if i+1!=length_of_nl then
                append_str=append_str+","
            end
        end
        
        append_str=append_str+"}"
        return append_str

    elif term(tree.name, "table_expr") then
        local key_tree=tree.node_list[0]
        local value_tree=tree.node_list[1]
        local left=Code_Generation_2_Javascript(sl, key_tree.node_list[0])
        local left_is_string=isString(left)
        if left_is_string==false and isdigit(left)==false then
            console.log("Error.. invalid key %s\n",left)
            process.exit(0)
        end
        if left_is_string==true then
            left=left[1:left.length-1]
        end
        
        local right=Code_Generation_2_Javascript(sl, value_tree)
        
        return left+":"+right
    
    
    elif term(tree.name, "table_value") then
        
        local nl=tree.node_list
        local var_name=Code_Generation_2_Javascript(sl,nl[0])
        local append_str=var_name
        js_isTableValue=true

        local i=1
        local length_of_nl=len(nl)
        for i<length_of_nl,i=i+1 then
            local key_tree=nl[i]
            local key_str=Code_Generation_2_Javascript(sl, key_tree)
            append_str=append_str+key_str
        end
        
        js_isTableValue=false
        return append_str
    
    elif term(tree.name, "key") then
        if term(tree.node_list[0].name,"slice") then
            
            local append_str=".slice("
            
            local nl=tree.node_list[0].node_list
            local left=nl[0]
            local right=nl[1]
            
            local left_str=Code_Generation_2_Javascript(sl, left)
            append_str=append_str+left_str
            
            # restore that value 
            js_isTableValue=false
            
            # does not append
            if term(right.name,"its_length") then
                console.log("")
            else
                append_str=append_str+","
                local right_str=Code_Generation_2_Javascript(sl, right)
                append_str=append_str+right_str
            end
            append_str=append_str+")"
            
            #        t        f       f
            # solve a[0:a.length-1].trim() problem
            js_isTableValue=true
            
            return append_str
        else
            local key_tree=tree.node_list[0]
            js_isTableValue=false
            local append_str="["+Code_Generation_2_Javascript(sl, key_tree)+"]"
            js_isTableValue=true
            return append_str
        end
    
    #~
     ( func
        (call toString)
        ( params
            (id b)
            (id c)
        )
     )
     
     ~#
    elif term(tree.name, "func") then
        local used_to_be_js_isTableValue=false
        local append_str="" #=tree.node_list->node.name
        if js_isTableValue==false then
            # i changed parser for func on 05/20/2013
            local func_name_string=Code_Generation_2_Javascript(sl,tree.node_list[0].node_list[0])
            local func_name= func_name_string[1:len(func_name_string)-1]            
            append_str=func_name
        else
            local func_name=Code_Generation_2_Javascript(sl,tree.node_list[0].node_list[0])
            # add []
            append_str="["+func_name+"]"
            
            # solve console.log(a()) -> console["log"](["a"]()) problem
            # change js_isTableValue to FALSE at first and then restore to TRUE
            used_to_be_js_isTableValue=true
            js_isTableValue=false
        end
        
        
        append_str=append_str+"("
        
        local params_tree=tree.node_list[1]
        local params_nl=params_tree.node_list

        local i=0
        local length_of_params_nl=len(params_nl)
        for i=0,i<length_of_params_nl,i=i+1 then
            append_str=append_str+Code_Generation_2_Javascript(sl, params_nl[i])
            if i+1!=length_of_params_nl then
                append_str=append_str+","
            end
        end 

        
        append_str=append_str+")"
        
        
        if used_to_be_js_isTableValue==true then
            js_isTableValue=true
        end
        
        return append_str
    
    # and( +(num 3)(num 4))(id a)
    elif term(tree.name, "and") or term(tree.name, "or") then
        local left_str=Code_Generation_2_Javascript(sl, tree.node_list[0])
        local right_str=Code_Generation_2_Javascript(sl, tree.node_list[1])
        local judge_sign="&&"
        if term(tree.name, "or") then
            judge_sign="||"
        end
        return left_str+judge_sign+right_str
    
    elif term(tree.name,"params") then
        local append_string=""
        local nl=tree.node_list

        local i=0
        local length_of_nl=len(nl)
        for i<length_of_nl,i=i+1 then
            if term(nl[i].name,"=") then
                console.log("Does not support = in params now \n")
            end
            local need_to_be_appended=Code_Generation_2_Javascript(sl, nl[i])
            # none params
            if term(need_to_be_appended, "null") then
                continue
            end
            
            append_string=append_string+need_to_be_appended

            if i+1!=length_of_nl then
                append_string=append_string+","
            end
            
        end 

        return append_string
    
    elif term(tree.name, "end") then
        return "}\n"
    
        
    elif term(tree.token_class, "num") then
        return tree.name
    
    elif term(tree.token_class, "string") then
        return tree.name

    # if must be behind 'id' to solve ' def value ()' problem
    elif term(tree.name, "value") then
        local nl=tree.node_list
        return Code_Generation_2_Javascript(sl, nl[0])
    
    
    elif ism_operator(tree.name) then
        local nl=tree.node_list
        local left=nl[0]
        local right=nl[1]
        
        local left_str=Code_Generation_2_Javascript(sl, left)
        local right_str=Code_Generation_2_Javascript(sl, right)
        
        if ((isdigit(left_str) or isString(left_str)) and (isdigit(right_str) or isString(right_str))) then
            local value=Walley_Calculation(left_str, right_str, tree.name)
            return value
        end
        
        
        local left_need_bracket=true
        local right_need_bracket=true
        
        if term(left.token_class, "id") or term(left.token_class, "string") or term(left.token_class, "num") then
            left_need_bracket=false
        end
        
        if term(right.token_class, "id") or term(right.token_class, "string") or term(right.token_class, "num") then
            right_need_bracket=false
        end
        
        
        local need_bracket=false
        if term(tree.name, "*") or term(tree.name, "//") or term(tree.name, "^") or term(tree.name, "%") then
            need_bracket=true
        end
        
        if need_bracket then
            #char *append_str=left_str
            if left_need_bracket then
                left_str="("+left_str+")"
            end
                
            
            if right_need_bracket then
                right_str="("+right_str+")"
            end
                        
            # change ^ to Math.pow()
            if term(tree.name, "^") then
                
                local append_str="Math.pow("+left_str+","+right_str+")"
                return append_str
            
            else
                local append_str=left_str+tree.name+right_str
                return append_str
            end
        else
            if term(tree.name, "^") then
              return  "Math.pow("+left_str+","+right_str+")"
            else
                local append_str=left_str
                append_str=append_str+tree.name
                append_str=append_str+right_str
                return append_str
            end
        end
    elif term(tree.name, "expr") then
        return Code_Generation_2_Javascript(sl, tree.node_list[0])
    
    elif term(tree.name, "return") then
        local append_str="return "
        local nl=tree.node_list
        append_str=append_str+Code_Generation_2_Javascript(sl, nl[0])
        append_str=append_str+";\n"
        # SL_addString(sl, append_str)
        return append_str
        
    else
        console.log("Code Generation Error..\n")
        process.exit(0)
    end
end

# return string type of output
exports.Code_Generation=def(input_str) then
    INCOMPLETE_STATEMENT=false
    local tl=Walley_Lexical_Analyzie(input_str)
    local tree=parser(tl)
    local sl=[]
    local output=Code_Generation_2_Javascript(sl,tree)

    if output!="" then
        sl.append(output)
    end


    local output_str=""
    local  length=len(sl)
    for i=0,i<length,i=i+1 then
        output_str=output_str+sl[i]
    end

    exports.INCOMPLETE_STATEMENT=INCOMPLETE_STATEMENT
    
    return output_str
end