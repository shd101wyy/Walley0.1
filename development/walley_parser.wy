
#~
	Copyright reserved Yiyi Wang 
	Please follow MIT license

	This file mainly deals with:
		parser
~#

import "walley_tree.wy"

#= walley_list.wy
def elements(tree, tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    local length_of_tl=len(tl)
    local index_of_comma=TL_indexOfTokenThatHasTokenString(tl, ",")
    # value
    if index_of_comma==-1 then
        local index_of_tl=TREE_INDEX
        TREE_addNode(tree,"value","")
        return value(TREE_getTreeAccordingToIndex(tree, index_of_tl), tl)
    # value ',' elements
    else
        local tl1=tl[0:index_of_comma]
        local tl2=tl[index_of_comma+1:length_of_tl]
        
        local index_of_tl1=TREE_INDEX
        TREE_addNode(tree,"value","")
       
        
        return value(TREE_getTreeAccordingToIndex(tree, index_of_tl1), tl1) and elements(tree, tl2)
    end
end


def value(tree, tl) then

    if INCOMPLETE_STATEMENT then
        return false
    end
    
    local length_of_tl=len(tl)

    # (null)
    if length_of_tl==0 then
        tree.name="none"
        tree.token_class="id"
        return true
    elif length_of_tl==1 then
        #   num
        #  | id
        #  | string
        if "num"==tl[0].TOKEN_CLASS
            or "string"==tl[0].TOKEN_CLASS
            or "id"==tl[0].TOKEN_CLASS then
            tree.name=tl[0].TOKEN_STRING
            tree.token_class=tl[0].TOKEN_CLASS
            return true
        # | list
        # | table
        elif "list_table"==tl[0].TOKEN_CLASS then
            tree.name=tl[0].TOKEN_STRING
            tree.token_class="table"

            # I changed key_index here to object
            local key_index=[val=0]
            return table(tree, tl,key_index)
        else
            return false
        end
    # func_value
    # table_value
    # func
    # relation
    # expr
    else 
        return func_value(tree, tl) or table_value(tree, tl) or func(tree, tl) or relation(tree,tl) or expr(tree, tl)
    end
end


#= walley.table.wy
# key_index is object [val=0]
def table_elements(tree, tl,key_index) then
    if INCOMPLETE_STATEMENT then
        return false
    end
    local length_of_tl=len(tl)
    local i=0
    local index_of_comma=-1

    for i=0,i<length_of_tl,i=i+1 then
        if term(tl[i].TOKEN_STRING,",") then
            index_of_comma=i
            break
        end
    end
    #| table_expr ',' table_elements
    if index_of_comma!=-1 then
        table_expr_tl=tl[0:index_of_comma]
        table_elements_tl=tl[index_of_comma+1:length_of_tl]
        local index1=TREE_INDEX
        TREE_addNode(tree, "table_expr", "")

        return table_expr(TREE_getTreeAccordingToIndex(tree, index1), table_expr_tl, key_index)
        and table_elements(tree, table_elements_tl, key_index)
    else
        local index=TREE_INDEX
        TREE_addNode(tree, "table_expr", "")
        return table_expr(TREE_getTreeAccordingToIndex(tree, index), tl, key_index)
    end
end


def table_expr(tree,tl,key_index) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end

    local length_of_tl=len(tl)
    # | '@' id '=' value
    if length_of_tl>3 and term(tl[0].TOKEN_CLASS, "@") and term(tl[1].TOKEN_CLASS, "id") and term(tl[2].TOKEN_STRING, "=") then
        local append_key=tl[1].TOKEN_STRING
        local length_of_append_key=len(append_key)
        local new_key="@"+append_key
        # THIS PLACE HAS PROBLEM WHILE PARSING KEY
        TREE_addNode(tree, new_key, "key")
        local index=TREE_INDEX
        TREE_addNode(tree, "value", "")
        return value(TREE_getTreeAccordingToIndex(tree, index), tl[3:length_of_tl])
    
    # id '=' value
    elif term(tl[0].TOKEN_CLASS, "id") and term(tl[1].TOKEN_STRING, "=") then
        local index1=TREE_INDEX
        TREE_addNode(tree, "key", "")
        
        local key_tl=Walley_Lexical_Analyzie(toString(tl[0].TOKEN_STRING))

        local key_tree=TREE_init("key")
        value(key_tree, key_tl)
        
        TREE_addTree(TREE_getTreeAccordingToIndex(tree, index1),key_tree)

        local index2=TREE_INDEX
        TREE_addNode(tree, "value", "")
        return value(TREE_getTreeAccordingToIndex(tree, index2), tl[2:length_of_tl])
    #              0           1       2
    #    |'[' (string|int) ']' '=' (value)
    elif term(tl[0].TOKEN_CLASS, "list_table") and tl[1]!=undefined and term(tl[1].TOKEN_STRING, "=") then
        # THIS PLACE HAS SOME PROBLEM
        #printf("'[' (string|int) ']' '=' (value)  HAS NOT BEEN IMPLEMENTED\n")
        
        local length=len(tl[0].TOKEN_STRING)
        local string_inside= tl[0].TOKEN_STRING[1:length-1]   
        
        local index1=TREE_INDEX
        TREE_addNode(tree, "key", "")
        
        local key_tl=Walley_Lexical_Analyzie(string_inside)
        TREE key_tree=TREE_init("key")
        value(key_tree, key_tl)
        
        TREE_addTree(TREE_getTreeAccordingToIndex(tree, index1),key_tree)
        
        local index2=TREE_INDEX
        TREE_addNode(tree, "value", "")
        
        
        return value(TREE_getTreeAccordingToIndex(tree, index2),tl[2:length_of_tl])

    #value
    else
        local index1=TREE_INDEX
        TREE_addNode(tree, "key", "")
        
        local key_tl=Walley_Lexical_Analyzie(key_index.val+"")
        local key_tree=TREE_init("key")
        value(key_tree, key_tl)
        
        TREE_addTree(TREE_getTreeAccordingToIndex(tree, index1),key_tree)
        
        
        local index=TREE_INDEX
        TREE_addNode(tree, "value", "")
      
        
        key_index.val=key_index.val+1
        
        return value(TREE_getTreeAccordingToIndex(tree, index),tl)
    end

    return false
end

#table    -> '[' table_elements ']'
def table(tree,tl,key_index) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    local length_of_tl=len(tl)
    
    if length_of_tl==1 then
        local list_string=tl[0].TOKEN_STRING
        local length_of_list_string=len(list_string)
        if list_string[0]=="[" and list_string[length_of_list_string-1]=="]" then
            # list_string [1,2]
            # list_string2 1,2
            local list_string2=list_string[1:len(list_string)-1].trim()
            
            # content empty
            # x=[]
            if list_string2=="" then
                return true
            end
            
            
            local table_tl=Walley_Lexical_Analyzie(list_string2)
            return table_elements(tree, table_tl, key_index)
        else
            return false
        end
    
    else
        return false
    end
end


def table_value(tree, tl) then
    
    if INCOMPLETE_STATEMENT==true then
        return false
    end
   
    local length_of_tl=len(tl)

    # check whether have m_operator to solve len(a)-1 parser error
    local i=0
    local count=0
    for i=0,i<length_of_tl,i=i+1 then
        if term(tl[i].TOKEN_STRING,"(") then
            count=count+1
        elif term(tl[i].TOKEN_STRING,")") then
            count=count-1
        end

        if count==0 and term(tl[i].TOKEN_CLASS,"m_operator") then
            return false
        end
    end

    #~
     id table_value_key
     
     // new support
     string table_value_key              // "hello".length()
     list_table table_value_key          // [1,2,3].length()
     num table_value_key                 //  13.toString()
     ~#
    if length_of_tl>=2 and
        (term(tl[0].TOKEN_CLASS, "id")
         or term(tl[0].TOKEN_CLASS, "string")
         or term(tl[0].TOKEN_CLASS, "list_table")
         or term(tl[0].TOKEN_CLASS, "num")
        )
        and
        (term(tl[1].TOKEN_STRING, ".") or term(tl[1].TOKEN_CLASS, "list_table"))
         then
        local index=TREE_INDEX
        TREE_addNode(tree, "table_value", "")
        
        
        TREE_addNode(TREE_getTreeAccordingToIndex(tree, index), tl[0].TOKEN_STRING, tl[0].TOKEN_CLASS)
        return table_value_key(TREE_getTreeAccordingToIndex(tree, index), tl[1:length_of_tl])
    # new support on 05/24/2013
    #func table_value_key
    elif length_of_tl>=3 and term(tl[0].TOKEN_CLASS, "id") and term(tl[1].TOKEN_STRING, "(") then
        local index=-1 # find index of )
        
        local i=0
        local count=0
        for i=0,i<len(tl),i=i+1 then
            if term(tl[i].TOKEN_STRING,"(") then
                count=count+1
            elif term(tl[i].TOKEN_STRING,")") then
                count=count-1
                if count==0 then
                    index=i
                    break
                end
            end
        end
        
        # fix 'add(3,4)' bug
        if index==length_of_tl-1 then
            return false
        end

        # fix 'a() and b()' bug
        if tl[i+1]!=undefined and term(tl[i+1].TOKEN_CLASS, "relation") then
            return false
        end
        
        local tree_index=TREE_INDEX
        TREE_addNode(tree, "table_value", "")
        local tree_index2=TREE_INDEX
        TREE_addNode(TREE_getTreeAccordingToIndex(tree, tree_index), "func", "")
        func(TREE_getTreeAccordingToIndex(tree, tree_index2), tl[0:index+1])
        
        return table_value_key(TREE_getTreeAccordingToIndex(tree, tree_index),tl[index+1:length_of_tl])

    
    # expr table_value_key                //  ("He"+"llo").length()   where expr can only be  inside '()'
    else
        if term(tl[0].TOKEN_STRING, "(") then
            
           
           
            local index_of_right=-1




            local i=0
            local count=0
            for i=0,i<len(tl),i=i+1 then
                if term(tl[i].TOKEN_STRING,"(") then
                    count=count+1
                elif term(tl[0].TOKEN_STRING,")") then
                    count=count-1
                    if count==0 then
                        index_of_right=i
                        break
                    end
                end
            end            
            if index_of_right==-1 then
                return false
            else
                if index_of_right==length_of_tl-1 then
                    return false
                end
                
                # solve (a+3)^2 like problem
                if term(tl[index_of_right+1].TOKEN_CLASS, "list_table")==false or term(tl[index_of_right+1].TOKEN_STRING, ".")==false then
                    return false
                end
                local index=TREE_INDEX
                TREE_addNode(tree, "table_value", "")
               
                local index2=TREE_INDEX
                TREE_addNode(TREE_getTreeAccordingToIndex(tree, index), "expr", "")
               
                return expr(TREE_getTreeAccordingToIndex(tree, index2),tl[0:index_of_right+1]) and
                table_value_key(TREE_getTreeAccordingToIndex(tree, index), tl[index_of_right+1:length_of_tl])
            end
        end
        return false
    end
end

def table_value_key(tree, tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    local length_of_tl=len(tl)
    
    # [(string|num)value|slice]        # slice need ":"    like ':3' ':3' or '0:3'
    if length_of_tl==1 and term(tl[0].TOKEN_CLASS, "list_table") then
        # get string inside []
        local length=len(tl[0].TOKEN_STRING)
        local string_inside=tl[0].TOKEN_STRING[1:length-1]
        
        local key_tl=Walley_Lexical_Analyzie(string_inside)
        
        # check whether have :
        local index_of_colon=-1
        local i=0
        for i=0,i<len(key_tl),i=i+1 then
            if term(key_tl[i].TOKEN_STRING,":") then
                index_of_colon=i
                break
            end
        end
        
        # not slice
        if index_of_colon==-1 then
            
            local index1=TREE_INDEX
            TREE_addNode(tree, "key", "")
            
            local key_tree=TREE_init(key_tree, "key")
            value(key_tree, key_tl)
            
            TREE_addTree(TREE_getTreeAccordingToIndex(tree, index1),key_tree)
            
            return true
        # slice
        else
            local length_of_key_tl=len(key_tl)
            local index1=TREE_INDEX
            TREE_addNode(tree, "key", "")
            
            local slice_tree=TREE_init("slice")
            
            local left_tl=none
            local right_tl=none
            
            # has no left
            if index_of_colon==0 then
                left_tl=none
            else
                left_tl=key_tl[0:index_of_colon]
            end
            
            # has no right
            if index_of_colon==length_of_key_tl-1 then
                right_tl=none
            else
                right_tl=key_tl[index_of_colon+1:length_of_key_tl]
            end
            # add left
            local index_left=TREE_INDEX
            if left_tl==none then
                TREE_addNode(slice_tree, "0","num")
            else
                TREE_addNode(slice_tree, "value", "")
                value(TREE_getTreeAccordingToIndex(slice_tree, index_left), left_tl)
            end
            # add right
            local index_right=TREE_INDEX
            if right_tl==none then
                TREE_addNode(slice_tree, "its_length","special")
            else
                TREE_addNode(slice_tree, "value", "")
                value(TREE_getTreeAccordingToIndex(slice_tree, index_right), right_tl)
            end

            TREE_addTree(TREE_getTreeAccordingToIndex(tree, index1),slice_tree)
            return true
        end
        
    
    #| '.' id
    elif length_of_tl==2 and term(tl[0].TOKEN_STRING,".") and term(tl[1].TOKEN_CLASS, "id") then
        local index1=TREE_INDEX
        TREE_addNode(tree, "key", "")
        
        local key_tl=Walley_Lexical_Analyzie(toString(tl[1].TOKEN_STRING))
        local key_tree=TREE_init("key")
        value(key_tree, key_tl)
        TREE_addTree(TREE_getTreeAccordingToIndex(tree, index1),key_tree)
        
        return true
    #| '.' func
    #| '.' func table_value_key                            // behind is [] or '.'
    elif length_of_tl>=4 and term(tl[0].TOKEN_STRING,".") and term(tl[1].TOKEN_CLASS, "id") and term(tl[2].TOKEN_STRING, "(") then
        # find index_of_right )
        local index_of_right=-1
        local i=0
        local count=0
        for i=0,i<len(tl),i=i+1 then
            if term(tl[i].TOKEN_STRING,"(") then
                count=count+1
            elif term(tl[i].TOKEN_STRING,")") then
                count=count-1
                if count==0 then
                    index_of_right=i
                    break
                end
            end
        end

        if index_of_right==-1 then
            INCOMPLETE_STATEMENT=true
            return false
        end

        
        #| '.' func
        if index_of_right==length_of_tl-1 then
            local index1=TREE_INDEX
            TREE_addNode(tree, "key", "")
            
            return func(TREE_getTreeAccordingToIndex(tree, index1), tl[1:length_of_tl])
        #| '.' func table_value_key                            // behind is [] or '.'
        else
            return table_value_key(tree, tl[0:index_of_right+1]) and table_value_key(tree, tl[index_of_right+1:length_of_tl])
        end
       
    #| [(string|num)value] table_value_key
    elif length_of_tl>=2 and term(tl[0].TOKEN_CLASS, "list_table") and
             (term(tl[1].TOKEN_STRING, ".") or term(tl[1].TOKEN_CLASS, "list_table"))
             then
        return table_value_key(tree, tl[0:1]) and table_value_key(tree, tl[1:length_of_tl])
    #| [(string|num)value] '(' params ')' table_value_key
    elif length_of_tl>=3 and term(tl[0].TOKEN_CLASS, "list_table") and term(tl[1].TOKEN_STRING, "(") then       
        # find index_of_right )
        local index=-1
        local i=0
        local count=0
        for i=0,i<len(tl),i=i+1 then
            if term(tl[i].TOKEN_STRING,"(") then
                count=count+1
            elif term(tl[i].TOKEN_STRING,")") then
                count=count-1
                if count==0 then
                    index=i
                    break
                end
            end
        end

        
        # index = -1 incomplete
        if index==-1 then
            INCOMPLETE_STATEMENT=true
            return false
        end
        
        
        local func_tree=TREE_init("func")
        local tree_index=TREE_INDEX
        TREE_addNode(func_tree, "", "table_call")
        TREE_addNode(TREE_getTreeAccordingToIndex(func_tree, tree_index), "", "")
        tree_index=tree_index+1

        # get string inside []
        local length=len(tl[0].TOKEN_STRING)
        local string_inside=tl[0].TOKEN_STRING[1:length-1]
        #====================
        local string_inside_tl=Walley_Lexical_Analyzie(string_inside)
        value(TREE_getTreeAccordingToIndex(func_tree, tree_index), string_inside_tl)

        tree_index=TREE_INDEX
        TREE_addNode(func_tree, "params", "")
        if 2!=index then
            params(TREE_getTreeAccordingToIndex(func_tree, tree_index), tl[2:index])
        end

        TREE_addTree(tree, func_tree)

        if index==length_of_tl-1 then
            return true
        end
        return table_value(tree, tl[index+1:length_of_tl])

    #| '.' id table_value_key                              // behind is [] or '.'
    elif length_of_tl>=3 and term(tl[0].TOKEN_STRING, ".") and term(tl[1].TOKEN_CLASS, "id")
             and (term(tl[2].TOKEN_STRING, ".") or term(tl[2].TOKEN_CLASS, "list_table"))
             then
        return table_value_key(tree, tl[0:2]) and table_value_key(tree, tl[2:length_of_tl])
    else
        return false
    end
end


#= walley_math_parser.wy
def expr(tree, tl) then
    if INCOMPLETE_STATEMENT then
        return false
    end
    
    # expr-> expr '+' expr
    # | expr '-' expr
    # | s_term
    local length_of_tl=len(tl)
    local count_of_parenthesis=0
        
    
    local i=length_of_tl-1
    for i>=0, i=i-1 then
        if tl[i].TOKEN_STRING=="(" then
            count_of_parenthesis=count_of_parenthesis+1
            continue
        end
        if tl[i].TOKEN_STRING==")" then
            count_of_parenthesis=count_of_parenthesis-1
            continue
        end
        # expr '+' expr
        # expr '-' expr
        if count_of_parenthesis==0 and ("+"==tl[i].TOKEN_STRING or "-"==tl[i].TOKEN_STRING ) then
            local sign=tl[i].TOKEN_STRING
            
            local index_of_first_sign=i
            
            # solve x=-1 or x=+1 problem
            if index_of_first_sign==0 then
                temp_tl=[]
                local temp_token=Token_init()
                temp_token.TOKEN_STRING="0"
                temp_token.TOKEN_CLASS="num"
                temp_token.TOKEN_START=-1
                temp_token.TOKEN_END=-1
                
                temp_tl.append(temp_token)

                local a=0
                for a=0,a<len(tl),a=a+1 then
                    temp_tl.append(tl[a])
                end

                return expr(tree,temp_tl)
            end
            
            
            local tl1=tl[0:index_of_first_sign]
            local tl2=tl[index_of_first_sign+1:length_of_tl]
            tree.name=sign
            
            local index_of_expr1_node=TREE_INDEX
            TREE_addNode(tree, "expr","")
            local index_of_expr2_node=TREE_INDEX
            TREE_addNode(tree, "expr","")
            
            return expr(TREE_getTreeAccordingToIndex(tree,index_of_expr1_node), tl1) and expr(TREE_getTreeAccordingToIndex(tree,index_of_expr2_node), tl2)
        end         
    end
    # s_term
    return s_term(tree, tl) 
end

def s_term(tree,tl) then
    if INCOMPLETE_STATEMENT then
        return false
    end
    local length_of_tl=len(tl)
    local count_of_parenthesis=0    
    
    local i=length_of_tl-1
    for  i>=0, i=i-1 then
        if tl[i].TOKEN_STRING=="(" then
            count_of_parenthesis=count_of_parenthesis+1
            continue
        end

        if tl[i].TOKEN_STRING==")" then
            count_of_parenthesis=count_of_parenthesis-1
            continue
        end
    
        #    s_term "*" p_term
        # |  s_term "/" p_term
        if count_of_parenthesis==0 and ("*"==tl[i].TOKEN_STRING or "/"==tl[i].TOKEN_STRING or "%"==tl[i].TOKEN_STRING) then
            local sign=tl[i].TOKEN_STRING
            
            local index_of_first_sign=i
            local tl1=tl[0:index_of_first_sign]
            local tl2=tl[index_of_first_sign+1:length_of_tl]
            
            tree.name=sign
            
            local current_index=tree.index
            TREE_addNode(tree, "s_term","")
            TREE_addNodeAtIndex(tree, current_index, "p_term","")
            
            local index_of_node1=TREE_INDEX-2
            local index_of_node2=TREE_INDEX-1
            
            
            return s_term(TREE_getTreeAccordingToIndex(tree,index_of_node1), tl1) and p_term(TREE_getTreeAccordingToIndex(tree,index_of_node2), tl2)
        end        
    end    

    # p_term
    return p_term(tree, tl)
end

def p_term(tree, tl) then
    if INCOMPLETE_STATEMENT then
        return false
    end
    #p_term -> p_term "^" factor
    #|  factor
    local length_of_tl=len(tl)
    local count_of_parenthesis=0
    
    local i=length_of_tl-1
    for  i>=0, i=i-1 then
        if tl[i].TOKEN_STRING=="(" then
            count_of_parenthesis=count_of_parenthesis+1
            continue
        end
        if tl[i].TOKEN_STRING==")" then
            count_of_parenthesis=count_of_parenthesis-1
            continue
        end
        #   p_term "^" factor
        if count_of_parenthesis==0 and ("^"==tl[i].TOKEN_STRING or "**"==tl[i].TOKEN_STRING ) then
            local sign="^"

            local index_of_first_sign=i
            local tl1=tl[0:index_of_first_sign]
            local tl2=tl[index_of_first_sign+1:length_of_tl]
            
            tree.name=sign
            
            local current_index=tree.index
            TREE_addNode(tree, "p_term","")
            TREE_addNodeAtIndex(tree, current_index, "factor","")
            
            local index_of_node1=TREE_INDEX-2
            local index_of_node2=TREE_INDEX-1
            
            
            return p_term(TREE_getTreeAccordingToIndex(tree,index_of_node1), tl1) and factor(TREE_getTreeAccordingToIndex(tree,index_of_node2), tl2)
        end 
    end
    
    # factor
    return factor(tree, tl)
end

#factor -> value
#| (expr)
def factor(tree, tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    local length_of_tl=len(tl)
    #| (expr)
    if term(tl[0].TOKEN_STRING,"(") and term(tl[length_of_tl-1].TOKEN_STRING, ")") then
        tree.name="expr"
        tree.token_class=""
        return expr(tree, TL_subtl(tl, 1, length_of_tl-1))
    # value
    else
        return value(tree, tl)
    end
end


#= walley_assignment.wy
def assignment(tree,tl) then
    
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    
    # | 'local' var_name '=' var_value
    local is_local=false
    if term(tl[0].TOKEN_STRING, "local") then
        is_local=true
    end
    
    
    local count=0
    local count_of_equal=0
    local index_of_equal=-1
    local i=0

    for i=0,i<len(tl),i=i+1 then
        if term(tl[i].TOKEN_STRING, "(")
            or term(tl[i].TOKEN_STRING, "if")
            or term(tl[i].TOKEN_STRING, "def")
            or term(tl[i].TOKEN_STRING, "for")
            or term(tl[i].TOKEN_STRING, "while") then
            count=count+1
        elif term(tl[i].TOKEN_STRING, ")")
              or term(tl[i].TOKEN_STRING, "end") then
            count=count-1
        end
        if count==0 and tl[i].TOKEN_STRING=="=" then
            count_of_equal=count_of_equal+1
            index_of_equal=i
        end
    end
    # it is not assignment
    if count_of_equal!=1 then
        return false
    else
        
        local length_of_tl=len(tl)

        local save_TREE_INDEX=TREE_INDEX
        
        TREE_INDEX=0
        local var_name_tree=TREE_init("var_name")
        local var_name_list=[]
        # exclude local
        if is_local==true then
            var_name_list=tl[1:index_of_equal]
        else
            var_name_list=tl[0:index_of_equal]
        end
        var_name(var_name_tree, var_name_list)
        
        TREE_INDEX=0
        local var_value_tree=TREE_init("var_value")
        local var_value_list=tl[index_of_equal+1:length_of_tl]
        
        
        var_value(var_value_tree, var_value_list)
        
        TREE_INDEX=save_TREE_INDEX
        
      

        
        local var_name_num=len(var_name_tree.node_list)
              
        local i=0
        local var_name_nl=var_name_tree.node_list
        local var_value_nl=var_value_tree.node_list
        for i<var_name_num, i=i+1 then
            local index=TREE_INDEX
            TREE_addNode(tree, "=", "")
      
            #local variable
            if is_local==true then
                TREE_addNode(TREE_getTreeAccordingToIndex(tree, index),"local", "")
            end

            TREE_addTree(TREE_getTreeAccordingToIndex(tree, index), var_name_nl[i])

            if var_value_nl[i]==undefined then
                local temp_tree=TREE_init()
                temp_tree.name="none"
                temp_tree.token_class="id"
                temp_tree.node_list=[]
                TREE_addTree(TREE_getTreeAccordingToIndex(tree, index), temp_tree)
            else
                TREE_addTree(TREE_getTreeAccordingToIndex(tree, index), var_value_nl[i])
            end
            # eg x,y=12
            # then x=12
            #      y=none
        end
        
        
        return true
    end
end

def var_name(tree,tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    local index_of_comma=TL_indexOfTokenThatHasTokenString(tl, ",")
    #var_name ',' var_name
    if index_of_comma!=-1 then
        local length_of_tl=len(tl)
        local tl1=tl[0:index_of_comma]
        local tl2=tl[index_of_comma+1:length_of_tl]
     
        return var_name(tree, tl1)
        and var_name(tree, tl2)
    
    else
        local length_of_tl=len(tl)
        # id
        if length_of_tl==1 then
            if "id"==tl[0].TOKEN_CLASS then
                TREE_addNode(tree, tl[0].TOKEN_STRING,"id")
                return true    
            else
                return false
            end
        # table_value
        else
            return table_value(tree, tl)
        end
    end
    return false
end

# where ',' is the , not inside def if elif else for while
def var_value(tree,tl) then
   
    
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    local length_of_tl=len(tl)
    local index_of_comma=-1
    
    local i=0
    local count=0

    for i<length_of_tl,i=i+1 then
        if term(tl[i].TOKEN_STRING, "def")
            or term(tl[i].TOKEN_STRING, "for")
            or term(tl[i].TOKEN_STRING, "if")
            or term(tl[i].TOKEN_STRING, "while")
            or term(tl[i].TOKEN_STRING, "(") then
            count=count+1
        end
        if term(tl[i].TOKEN_STRING, "end")
            or term(tl[i].TOKEN_STRING, ")") then
            count=count-1
        end
        if count==0 and term(tl[i].TOKEN_STRING, ",") then
            index_of_comma=i
            break
        end
    end
    if count!=0 then
        INCOMPLETE_STATEMENT=true
        return false
    end
        
    #value,var_value
    if index_of_comma!=-1 then
        local tl1=tl[0:index_of_comma]
        local tl2=tl[index_of_comma+1:length_of_tl]
        
        local index_of_tl1=TREE_INDEX
        TREE_addNode(tree, "value", "")
        
        
        return value(TREE_getTreeAccordingToIndex(tree, index_of_tl1), tl1) and var_value(tree,tl2)
    
    #value
    else
        
        local index_of_tl=TREE_INDEX
        TREE_addNode(tree,"value","")

        return value(TREE_getTreeAccordingToIndex(tree, index_of_tl), tl)
    end
end


#= walley_assignment_function.wy
def func_assign(tree, tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    local length_of_tl=len(tl)
    if length_of_tl>=4 and term(tl[0].TOKEN_STRING, "def") and term(tl[1].TOKEN_STRING, "(") then
        # find )
        local index_of_right=-1
        local count=0
        local i=0
        for i<length_of_tl,i=i+1 then
            if term(tl[i].TOKEN_STRING,"(") then
                count=count+1
            end
            if term(tl[i].TOKEN_STRING,")") then
                count=count-1
                if count==0 then
                    index_of_right=i
                    break
                end
            end
        end

        if index_of_right==-1 then
            INCOMPLETE_STATEMENT=true
            console.log("INCOMPLETE_STATEMENT func_assign\n")
            process.exit(0)
        else
            TREE_addNode(tree, "def", "")
            local index=TREE_INDEX
            TREE_addNode(tree, "params", "")
            
            local params_tl=[]
            # has params
            if index_of_right!=2 then
                params_tl=tl[2:index_of_right]
            # does not have params
            else
                params_tl=[]
                local add_token=Token_init()
                add_token.TOKEN_CLASS="id"
                add_token.TOKEN_STRING="none"
                params_tl.append(add_token)
            end     
            return params(TREE_getTreeAccordingToIndex(tree, index), params_tl)
        end
    end 
    return false
end

# return_stm -> 'return' value
def return_stm(tree, tl) then
    if INCOMPLETE_STATEMENT == true then
        return false
    end

    local length_of_tl=len(tl)
    if length_of_tl>=2 and term(tl[0].TOKEN_STRING, "return") then
        local index1=TREE_INDEX
        TREE_addNode(tree, "return", "")
        local index2=TREE_INDEX
        TREE_addNode(TREE_getTreeAccordingToIndex(tree, index1), "value", "")
        
        return value(TREE_getTreeAccordingToIndex(tree, index2),tl[1:length_of_tl])
    end
    return false
end


# func_value -> func_assign walley_statements 'end'
def func_value(tree, tl) then
    if INCOMPLETE_STATEMENT == true then
        return false
    end
    local length_of_tl=len(tl)
    if term(tl[0].TOKEN_STRING, "def") and term(tl[length_of_tl-1].TOKEN_STRING, "end") then
        tree.name="func_value"
        tree.token_class=""

        local index_of_then=TL_indexOfTokenThatHasTokenString(tl, "then")
        if index_of_then==-1 then
            INCOMPLETE_STATEMENT=true
            return false
        end
        
               
       
        return func_assign(tree, tl[0:index_of_then+1])
        and walley_statements(tree, tl[index_of_then+1:length_of_tl-1])
        and end_stm(tree, tl[length_of_tl-1:length_of_tl])
    end
    return false
end

#= walley_function.wy
def params(tree, tl)then
    if INCOMPLETE_STATEMENT == true then
        return false
    end
    # has no params
    if len(tl)==0 then
        return true
    end
    local length_of_tl=len(tl)
    local index_of_comma=-1
    local count=0
    local i=0
    for i=0,i<length_of_tl,i=i+1 then
        if term(tl[i].TOKEN_STRING,"(") then
            count=count+1
            continue
        end
        if term(tl[i].TOKEN_STRING,")") then
            count=count-1
            continue
        end
        if count==0 and term(tl[i].TOKEN_STRING,",") then
            index_of_comma=i
            break
        end
    end        
    # -> assignment
    # -> value
    if index_of_comma==-1 then
        
        if assignment(tree, tl)==true then
            return true
        else
                    
            local index=TREE_INDEX
            TREE_addNode(tree, "value", "")
            
            return value(TREE_getTreeAccordingToIndex(tree, index), tl)
        end
    # -> assignment ',' params
    # -> value ',' params
    else
        
        local tl1=tl[0:index_of_comma]
        local tl2=tl[index_of_comma+1:length_of_tl]
        
        if assignment(tree, tl1)==true then
            return params(tree, tl2)
        else
            local index_of_tl1=TREE_INDEX
            TREE_addNode(tree, "value","")
            return value(TREE_getTreeAccordingToIndex(tree, index_of_tl1), tl1) and params(tree,tl2)
        end
    end
end

def func(tree, tl) then
          
    if INCOMPLETE_STATEMENT == true then
        return false
    end

    local length_of_tl=len(tl)
    # id '(' params ')'
    local index_of_left=TL_indexOfTokenThatHasTokenString(tl, "(")
    local index_of_right=-1 # find )

    if index_of_left==-1 then
        return false
    end

    local i=0
    local count=0
    for i<length_of_tl,i=i+1 then
        if term(tl[i].TOKEN_STRING,"(") then
            count=count+1
        elif term(tl[i].TOKEN_STRING,")") then
            count=count-1
            if count==0 then
                index_of_right=i
                break
            end
        end
    end

    if index_of_right==-1 then
        INCOMPLETE_STATEMENT=true
        return false
    end
    
    # false
    if index_of_right+1!=length_of_tl or index_of_left==-1 or index_of_left==0 then
        return false
    else
        local test_id=tl[0:index_of_left]
        local params_tl=[]
        # no params
        if index_of_left+1==index_of_right then   
            params_tl=[]
        # has params
        else
            params_tl=tl[index_of_left+1:index_of_right]
        end
        

        
        local length_of_test_id=len(test_id)
        if length_of_test_id!=1 or test_id[0].TOKEN_CLASS!="id" then
            return false
        end

        
        tree.name="func"
        tree.token_class=""
        TREE_addNode(tree, "", "call")
        TREE_addNode(TREE_getTreeAccordingToIndex(tree, TREE_INDEX-1),toString(test_id[0].TOKEN_STRING), "string")
        local index=TREE_INDEX
        TREE_addNode(tree, "params", "")
        
        return params(TREE_getTreeAccordingToIndex(tree, index), params_tl)
    end
end

#= walley_judge.wy

def relation(tree, tl) then
    if INCOMPLETE_STATEMENT == true then
        return false
    end
    
    local length_of_tl=len(tl)

    local i=length_of_tl-1
    local count=0
    local index_of_and_or=-1
    for i>=0, i=i-1 then
        if term(tl[i].TOKEN_STRING, "(") then
            count=count+1
            continue
        end
        if term(tl[i].TOKEN_STRING, ")") then
            count=count-1
            continue
        end
        # |relation 'and' relation
        # |relation 'or'  relation
        if count==0 and term(tl[i].TOKEN_CLASS, "relation") and tl[i].TOKEN_STRING!="not" then
            index_of_and_or=i
            
            local and_or_string=tl[i].TOKEN_STRING
            
            local tl1=tl[0:index_of_and_or]
            local tl2=tl[index_of_and_or+1:length_of_tl]
            
            local index=TREE_INDEX
            TREE_addNode(tree, and_or_string,"")
            local index1=TREE_INDEX
            TREE_addNodeAtIndex(tree,index, "relation", "")
            local index2=TREE_INDEX
            TREE_addNodeAtIndex(tree, index, "relation", "")
            
            return relation(TREE_getTreeAccordingToIndex(tree, index1), tl1) and relation(TREE_getTreeAccordingToIndex(tree, index2), tl2)            
        end
    end
    
    # |not relation
    if term(tl[0].TOKEN_STRING, "not") then
        TREE_addNode(tree, "not", "")
        local index=TREE_INDEX
        TREE_addNodeAtIndex(tree, index-1, "relation", "")
        return relation(TREE_getTreeAccordingToIndex(tree, index), tl[1:length_of_tl])
    end
    return simple_relation(tree, tl)
end


def simple_relation(tree,tl) then
    if INCOMPLETE_STATEMENT == true then
        return false
    end

    local length_of_tl=len(tl)
    
    #'(' relation ')'
    if term("(", tl[0].TOKEN_STRING) and term(")",tl[length_of_tl-1].TOKEN_STRING) then
        return relation(tree, tl[1:length_of_tl-1])
    # value judge_sign value
    # expr
    else
        tree.name="simple_relation"
        
        local index_of_judge_sign=TL_indexOfTokenThatHasTokenClass(tl, "judge_sign")
        
        # expr
        if index_of_judge_sign==-1 then
            return expr(tree, tl)
        end
        
        # value judge_sign value
        local tl1=tl[0:index_of_judge_sign]
        local tl2=tl[index_of_judge_sign+1:length_of_tl]
        
        local judge_sign=tl[index_of_judge_sign].TOKEN_STRING
        
        # swap tl1 and tl2
        # and change judge sign
        # for virtual machine
        if term(">=", judge_sign) or term(">", judge_sign) then
            local temp_tl=tl1
            tl1=tl2
            tl2=temp_tl
            if term(">=", judge_sign) then
                judge_sign="<="
            else
                judge_sign="<"
            end
        end
        
        local index=TREE_INDEX
        TREE_addNode(tree, judge_sign, "")
        
        local temp_tree=TREE_getTreeAccordingToIndex(tree, index)
        
        local index1=TREE_INDEX
        TREE_addNode(temp_tree, "value", "")
        local index2=TREE_INDEX
        TREE_addNode(temp_tree, "value", "")
        return value(TREE_getTreeAccordingToIndex(tree, index1), tl1) and value(TREE_getTreeAccordingToIndex(tree, index2), tl2)

    end    
    return false
end




#= walley_statements.wy

def if_stms(tree, tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end

    local length_of_tl=len(tl)
    
    #if_stms -> 'if' relation 'then' walley_statements 'end'
    if term(tl[0].TOKEN_STRING, "if") then
        local index_of_then=TL_indexOfTokenThatHasTokenString(tl, "then")
        if index_of_then==-1 then
            INCOMPLETE_STATEMENT=true
            return false
        end
        
        if term(tl[length_of_tl-1].TOKEN_STRING, "end") and length_of_tl>2 then
            local relation_tl=tl[1:index_of_then]
            TREE_addNode(tree, "if", "")
            local index=TREE_INDEX
            TREE_addNode(tree, "relation", "")
            return relation(TREE_getTreeAccordingToIndex(tree, index), relation_tl) and walley_statements(tree, tl[index_of_then+1:length_of_tl-1])
        
        # incomplete
        else
            INCOMPLETE_STATEMENT=true
            return false
        end
    end
    return false
end

def elif_stms(tree, tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end

    local length_of_tl=len(tl)
    # elif_stms -> 'elif' relation 'then' walley_statements 'end'
    if term(tl[0].TOKEN_STRING, "elif") then
        local index_of_then=TL_indexOfTokenThatHasTokenString(tl, "then")
        if index_of_then==-1 then
            INCOMPLETE_STATEMENT=true
            return false
        end
        if term(tl[length_of_tl-1].TOKEN_STRING, "end") and length_of_tl>2 then
            local relation_tl=tl[1:index_of_then]
            
            TREE_addNode(tree, "elif", "")
            local index=TREE_INDEX
            TREE_addNode(tree, "relation", "")
            return relation(TREE_getTreeAccordingToIndex(tree, index), relation_tl) and walley_statements(tree, tl[index_of_then+1:length_of_tl-1])
        # incomplete
        else
            INCOMPLETE_STATEMENT=true
            return false
        end
    end
    return false
end

def else_stms(tree, tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    local length_of_tl=len(tl)

    # 'else'
    if term(tl[0].TOKEN_STRING, "else") then
        if term(tl[length_of_tl-1].TOKEN_STRING, "end") then
            TREE_addNode(tree, "else", "")
            return walley_statements(tree, tl[1:length_of_tl-1])
        else
            INCOMPLETE_STATEMENT=true
            return false
        end
    end
    return false
end

def while_stms(tree, tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    local length_of_tl=len(tl)
    #'while' relation 'then'
    if term(tl[0].TOKEN_STRING, "while") then
        local index_of_then=TL_indexOfTokenThatHasTokenString(tl, "then")
        if index_of_then==-1 then
            INCOMPLETE_STATEMENT=true
            return false
        end
        
        if term(tl[length_of_tl-1].TOKEN_STRING, "end") and length_of_tl>2 then
            local relation_tl=tl[1:index_of_then]

            TREE_addNode(tree, "while", "")
            local index=TREE_INDEX
            TREE_addNode(tree, "relation", "")
            return relation(TREE_getTreeAccordingToIndex(tree, index), relation_tl)
                and walley_statements(tree, tl[index_of_then+1:length_of_tl-1])
                and end_stm(tree, tl[length_of_tl-1:length_of_tl])
        # incomplete
        else
            INCOMPLETE_STATEMENT=true
            return false
        end
    end
    return false
end

def for_stms(tree,tl) then
    if term(tl[0].TOKEN_STRING, "for")==false then
        return false
    end
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    
    local length_of_tl=len(tl)
    
    
     
    # check 
    # |  'for' id ',' id 'in' value 'then' walley_statements 'end'
    # |  'for' id        'in' value 'then' walley_statements 'end'
    # assume it is correct
    if term(tl[4].TOKEN_STRING, "in") or term(tl[2].TOKEN_STRING, "in") then
        local index_of_then=-1
        # check then index;
        local i=0
        for i<length_of_tl,i=i+1 then
            if term(tl[i].TOKEN_STRING,"then") then
                index_of_then=i
                break
            end
        end
        
        TREE_addNode(tree, "foreach", "")
        
        # for i,v in x
        # check i error
        if term(tl[1].TOKEN_CLASS, "id")==false then
            Walley_Print_Error(TL_toString(tl), "for each statements error, for i,v in value, i,v must be id", tl[1].TOKEN_START)
        end
        
        # add i
        TREE_addNode(tree, tl[1].TOKEN_STRING, "foreach_index")
        
        if term(tl[2].TOKEN_STRING, ",") then
            # check v error
            if term(tl[3].TOKEN_CLASS, "id")==false then
                Walley_Print_Error(TL_toString(tl), "for each statements error, for i,v in value, i,v must be id", tl[3].TOKEN_START)
            end
            
            # add v
            TREE_addNode(tree, tl[3].TOKEN_STRING, "foreach_value")
            #tl=tl->next->next->next->next->next # value
            
            # add in value
            local index=TREE_INDEX
            TREE_addNode(tree, "", "foreach_in")
            TREE_addNode(TREE_getTreeAccordingToIndex(tree, index), "value", "")
            index=index+1
            value(TREE_getTreeAccordingToIndex(tree, index),tl[5:index_of_then])
        else
            # add v
            TREE_addNode(tree, "", "foreach_value")
            #tl=tl->next->next->next; // value
            
            # add in value
            local index=TREE_INDEX
            TREE_addNode(tree, "", "foreach_in")
            TREE_addNode(TREE_getTreeAccordingToIndex(tree, index), "value", "")
            index=index+1
            value(TREE_getTreeAccordingToIndex(tree, index), tl[3:index_of_then])
        end
        
        return walley_statements(tree, tl[index_of_then+1:length_of_tl-1])
         and end_stm(tree, tl[length_of_tl-1:length_of_tl])
    end
    
    local num_of_comma=0
    local count_of_p=0 # count of ()

    local index_of_comma=[-1,-1,-1]
        
    local index=0
    local i=0
    
    local index_of_then=-1
    
    for i<length_of_tl,i=i+1 then
        if term(tl[i].TOKEN_STRING,"then") then
            index_of_then=i
            break
        end

        if term(tl[i].TOKEN_STRING,"(") then
            count_of_p=count_of_p+1
            continue
        end

        if term(tl[i].TOKEN_STRING,")") then
            count_of_p=count_of_p-1
            continue
        end

        if count_of_p==0 and term(tl[i].TOKEN_STRING,",") then
            if index<2 then
                index_of_comma[index]=i
                index=index+1
            end
            num_of_comma=num_of_comma+1
        end
    end
    
    # incomplete
    if index_of_then==-1 or term(tl[length_of_tl-1].TOKEN_STRING, "end")==false then
        INCOMPLETE_STATEMENT=true
        return false
    end
    
    if length_of_tl!=2
        and num_of_comma!=0
        and num_of_comma<=2
        then
        #|  'for' simple_relation ',' assignment 'then' walley_statements 'end'
        if num_of_comma==1 then
            local simple_relation_tl=tl[1:index_of_comma[0]]
            local assignment_tl=tl[index_of_comma[0]+1:index_of_then]
        
            TREE_addNode(tree, "for", "")
            local index_of_sr=TREE_INDEX
            TREE_addNode(tree, "simple_relation", "")
            local index_of_a=TREE_INDEX
            TREE_addNode(tree, "assignment", "")
            
            return simple_relation(TREE_getTreeAccordingToIndex(tree, index_of_sr), simple_relation_tl)
            and assignment(TREE_getTreeAccordingToIndex(tree, index_of_a), assignment_tl)
            and walley_statements(tree, tl[index_of_then+1:length_of_tl-1])
            and end_stm(tree, tl[length_of_tl-1:length_of_tl])
        
        #|  'for' ',' simple_relation ',' assignment 'then' walley_statements 'end'
        #|  'for' assignment ',' simple_relation ',' assignment 'then' walley_statements 'end'
        else
            #|  'for' ',' simple_relation ',' assignment 'then' walley_statements 'end'
            if term(tl[1].TOKEN_STRING, ",") then
                local simple_relation_tl=tl[2:index_of_comma[1]]
                local assignment_tl=tl[index_of_comma[1]+1:index_of_then]
                
                TREE_addNode(tree, "for", "")
                local index_of_sr=TREE_INDEX
                TREE_addNode(tree, "simple_relation", "")
                local index_of_a=TREE_INDEX
                TREE_addNode(tree, "assignment", "")
                
                return simple_relation(TREE_getTreeAccordingToIndex(tree, index_of_sr), simple_relation_tl)
                and assignment(TREE_getTreeAccordingToIndex(tree, index_of_a), assignment_tl)
                and walley_statements(tree, tl[index_of_then+1:length_of_tl-1])
                and end_stm(tree, tl[length_of_tl-1:length_of_tl])
            
            #|  'for' assignment ',' simple_relation ',' assignment 'then' walley_statements 'end'

            else
                local assignment_tl1=tl[1:index_of_comma[0]]
                local simple_relation_tl=tl[index_of_comma[0]+1:index_of_comma[1]]
                local assignment_tl2=tl[index_of_comma[1]+1:index_of_then]
                
                TREE_addNode(tree, "for","")
                local index_of_a_tl1=TREE_INDEX
                TREE_addNode(tree, "assignment", "")
                local index_of_sr=TREE_INDEX
                TREE_addNode(tree, "simple_relation","")
                local index_of_a_tl2=TREE_INDEX
                TREE_addNode(tree, "assignment","")
                
                return assignment(TREE_getTreeAccordingToIndex(tree, index_of_a_tl1), assignment_tl1)
                    and simple_relation(TREE_getTreeAccordingToIndex(tree, index_of_sr),simple_relation_tl)
                    and assignment(TREE_getTreeAccordingToIndex(tree, index_of_a_tl2),assignment_tl2)
                    and walley_statements(tree, tl[index_of_then+1:length_of_tl-1])
                    and end_stm(tree, tl[length_of_tl-1:length_of_tl])
            end
        end
    end
    return false
end

def func_stms(tree, tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    local length_of_tl=len(tl)
    #'def' func 'then'
    if term(tl[0].TOKEN_STRING, "def") then
        if length_of_tl>2 and term(tl[length_of_tl-1].TOKEN_STRING, "then") then
            TREE_addNode(tree, "def", "")
            
            local func_tl=tl[1:length_of_tl-1]
            
            local index=TREE_INDEX
            TREE_addNode(tree, "func","")
            return func(TREE_getTreeAccordingToIndex(tree, index), func_tl)
             and end_stm(tree, tl[length_of_tl-1:length_of_tl])
        # incomplete 
        else
            INCOMPLETE_STATEMENT=true
            return false
        end
    end
    return false
end



def end_stm(tree, tl) then
    
    if INCOMPLETE_STATEMENT==true then
        return false
    end

    if len(tl)==1 and term(tl[0].TOKEN_CLASS, "end") then
        TREE_addNode(tree, "end","")
        return true
    end
    return false
end

# def_stms -> 'def' func_name_stm '(' params ')' 'then' walley_statements 'end'
def def_stms(tree, tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    local length_of_tl=len(tl)

    if term(tl[0].TOKEN_STRING, "def") and term(tl[1].TOKEN_STRING, "(")==false then
        local index_of_then=TL_indexOfTokenThatHasTokenString(tl, "then")
        local index_of_left_bracket=TL_indexOfTokenThatHasTokenString(tl, "(")
        if index_of_then==-1 then
            INCOMPLETE_STATEMENT=true
            return false
        end
        
        if term(tl[length_of_tl-1].TOKEN_STRING, "end")==false then
            INCOMPLETE_STATEMENT=true
            return false
        end
        
        local new_tl=[]
        local begin=1

        local i=0
        for i<index_of_left_bracket,i=i+1 then
            if i>=begin then
                new_tl.append(tl[i])
            end
        end

        local add_token=Token_init()
        add_token.TOKEN_STRING="="
        add_token.TOKEN_CLASS="assignment_operator"
        new_tl.append(add_token)
        
        i=0
        for i=0, i<length_of_tl, i=i+1 then
            if i>=begin and i<index_of_left_bracket then
                continue
            end
            new_tl.append(tl[i])
        end
        
        return assignment(tree, new_tl)
    else
        return false
    end
end

#self_operator_stm
# x++
# var_name self_operator
def self_operator_stm(tree,tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    local length_of_tl=len(tl)
    if tl[length_of_tl-1].TOKEN_CLASS=="self_operator" then
        local index = TREE_INDEX
        TREE_addNode(tree,"self_operator_stm","")

        local valid_var_name=var_name(TREE_getTreeAccordingToIndex(tree, index), tl.slice(0, length_of_tl - 1))
        if valid_var_name==true then
            TREE_addNode(TREE_getTreeAccordingToIndex(tree, index), tl[length_of_tl - 1]["TOKEN_STRING"],"self_operator")
            return true
        else
            console.log("Error.. invalid self operation\n")
            process.exit(0)
        end
    else
        return false
    end
end

# x += 12
# x              +=                  12
# var_name self_assignment_operator value

def self_assignment_stm(tree,tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    local length_of_tl=len(tl)
    local index_of_self_assignment_operator=TL_indexOfTokenThatHasTokenClass(tl,"self_assignment")
    if index_of_self_assignment_operator==-1 then
        return false
    else
        local var_name_tl = tl[0:index_of_self_assignment_operator]
        local var_value_tl = tl[index_of_self_assignment_operator+1:length_of_tl]

        local index=TREE_INDEX
        TREE_addNode(tree,"self_assignment_stm","")
        local valid_var_name=var_name(TREE_getTreeAccordingToIndex(tree, index), var_name_tl)
        if valid_var_name==false then
            return false
        end

        TREE_addNode(TREE_getTreeAccordingToIndex(tree,index),tl[index_of_self_assignment_operator].TOKEN_STRING,"self_assignment")

        local index2=TREE_INDEX
        TREE_addNode(TREE_getTreeAccordingToIndex(tree, index),"","value")
        local valid_var_value = value(TREE_getTreeAccordingToIndex(tree, index2), var_value_tl)
        
        if valid_var_value==false then
            return false
        else
            return true
        end
    end

end

# import "hello.wy"
# import import_file
# only support 'import string' now
def import_stm(tree,tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    if tl[0].TOKEN_CLASS=="import" then
        TREE_addNode(tree,"import","")
        local index=TREE_INDEX
        local length_of_tl=len(tl)
        if length_of_tl!=2 or tl[1].TOKEN_CLASS!="string" then
            console.log("Error.. only support import statements like 'import \" hello.wy \"'")
            process.exit(0)
        end
        TREE_addNode(tree,tl[1].TOKEN_STRING,"import_file")
        return true
    else
        return false
    end    
end
def statements(tree, tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
    return import_stm(tree,tl)
        or self_operator_stm(tree,tl)
        or self_assignment_stm(tree,tl)
        or return_stm(tree, tl)
        or if_stms(tree, tl)
        or elif_stms(tree, tl)
        or else_stms(tree, tl)
        or while_stms(tree, tl)
        or for_stms(tree, tl)
        or def_stms(tree, tl)
        or end_stm(tree, tl)
        or assignment(tree, tl)
        or value(tree, tl)
end

#walley_statements ->
#| statements, statements        // use sentences_separation
def walley_statements(tree, tl) then
    if INCOMPLETE_STATEMENT==true then
        return false
    end
   
    local temp_tl=[val=[]]
    local begin=[val=0]
    
    while sentences_separation(tl, temp_tl, begin)==true then
        if INCOMPLETE_STATEMENT==true then
            return false
        end
        
        local index=TREE_INDEX
        TREE_addNode(tree, "statements", "")
        
        if statements(TREE_getTreeAccordingToIndex(tree, index), temp_tl.val)==false then
            console.log("Walley Statements Parse Error\n")
            return false
        end
    end
    if INCOMPLETE_STATEMENT==true then
            return false
    end
    return true
end

# output_tl=[val=[]] 
# begin=[val=0]
# need to use .val
def sentences_separation(tl, output_tl,begin) then
    local length_of_tl=len(tl)
    
    if begin.val>=length_of_tl then
        return false
    end
    
    i=begin.val

    local count_of_parenthesis=0 # count of ( )

    for  i<length_of_tl, i=i+1 then
        if tl[i].TOKEN_STRING=="(" then
            count_of_parenthesis++
        end

        if tl[i].TOKEN_STRING==")" then
            count_of_parenthesis--
        end
        
        # x=1 y=2 ->
        # x=1
        # y=2
        if i<length_of_tl-1 and (term(tl[i].TOKEN_CLASS, "num") or term(tl[i].TOKEN_CLASS, "string") or term(tl[i].TOKEN_CLASS, "id") or term(tl[i].TOKEN_CLASS, "list_table") or term(tl[i].TOKEN_STRING, ")") or term(tl[i].TOKEN_CLASS,"self_operator"))
            and (term(tl[1+i].TOKEN_CLASS, "id") or term(tl[1+i].TOKEN_CLASS, "num")
                or term(tl[i+1].TOKEN_CLASS, "return") or term(tl[i+1].TOKEN_STRING, "continue") or term(tl[1+i].TOKEN_STRING, "break") or term(tl[1+i].TOKEN_CLASS, "local") or term(tl[i+1].TOKEN_CLASS,"import")) then
            local end_index=i+1
            local ahead_tl=tl[begin.val:end_index]
            output_tl.val=ahead_tl
            begin.val=end_index
            return true
        end
        
        # find end corresponding to that def
        # def (num1,num2) return num1+num2 end
        # then set i to that end
        if  count_of_parenthesis==0 and
            (term(tl[i].TOKEN_STRING, "def") or
            term(tl[i].TOKEN_STRING, "for") or 
            term(tl[i].TOKEN_STRING, "while")) then
            
            # return ahead Token_List
            if begin.val!=i then
                if term(tl[i].TOKEN_STRING, "def") and term(tl[i+1].TOKEN_STRING, "(") then
                   #nothing 
                   console.log("")
                else
                    local end_index=i
                    local ahead_tl=tl[begin.val:end_index]
                
                    begin.val=end_index
                    output_tl.val=ahead_tl
                    return true
                end
            end
            
            local count=0
            for i<length_of_tl, i=i+1 then
                if term(tl[i].TOKEN_STRING, "def")
                    or term(tl[i].TOKEN_STRING, "for")
                    or term(tl[i].TOKEN_STRING, "if")
                    or term(tl[i].TOKEN_STRING, "while") then
                    count=count+1
                end
                if term(tl[i].TOKEN_STRING, "end") then
                    count=count-1
                end
                if count==0 then
                    break
                end
            end
            
            if count==0 then
                local end_index=i+1
                local ahead_tl=tl[begin.val:end_index]
                output_tl.val=ahead_tl
                begin.val=end_index
                return true
            else
                INCOMPLETE_STATEMENT=true
                return false
            end
        end
        
        
        # find 'end' or 'elif' or 'else'
        # if no 'end' found--- incomplete
        # if find 'elif' or 'else', add 'end' manually
        if term(tl[i].TOKEN_STRING, "if") then 
            # return ahead Token_List
            if begin.val!=i then
                
                local end_index=i
                local ahead_tl=tl[begin.val:end_index]
                begin.val=end_index
                output_tl.val=ahead_tl
                return true
            end
            
            
            local count_of_if=0
            local count_of_end=0
            for  i<length_of_tl,i=i+1 then
                if term(tl[i].TOKEN_STRING, "if")
                or term(tl[i].TOKEN_STRING, "def")
                or term(tl[i].TOKEN_STRING, "while")
                or term(tl[i].TOKEN_STRING, "for") then
                    count_of_if=count_of_if+1
                    count_of_end=count_of_end+1
                end
                
                if term(tl[i].TOKEN_STRING, "end") then
                    count_of_if=count_of_if-1
                    count_of_end=count_of_end-1
                end
                
                if count_of_end==0 then
                    break
                end
                
                if count_of_if==1 and
                    (term(tl[i].TOKEN_STRING, "elif")
                     or term(tl[i].TOKEN_STRING, "else"))
                    then
                    
                    local end_index=i
                    local ahead_tl=tl[begin.val:end_index]
                    local end_token=Token_init()
                    end_token.TOKEN_STRING="end"
                    end_token.TOKEN_CLASS="end"
                    ahead_tl.append(end_token)
                    
                    begin.val=end_index
                    output_tl.val=ahead_tl
                    
                    return true
                end
            end
            
            # incomplete
            if count_of_if!=count_of_end or count_of_if!=0 then
                INCOMPLETE_STATEMENT=true
                return false
            # complete
            #~
             eg: 
             if x>0 then
                if x>3 then
                    x=12
                end
             end
             
            ~# 
            else
                local end_index=i+1
                local ahead_tl=tl[begin.val:end_index]
                
                begin.val=end_index-1
                output_tl.val=ahead_tl
                return true
            end
        end
        
        # elif
        if term(tl[i].TOKEN_STRING, "elif") then
            local count_of_if=0
            local count_of_end=0
            local temp_i=i
            for  i<length_of_tl, i=i+1 then
                if term(tl[i].TOKEN_STRING, "if")
                or term(tl[i].TOKEN_STRING, "def")
                or term(tl[i].TOKEN_STRING, "while")
                or term(tl[i].TOKEN_STRING, "for") then
                    count_of_if=count_of_if+1
                    count_of_end=count_of_end+1
                end
                
                if term(tl[i].TOKEN_STRING, "end") then
                    count_of_end=count_of_end-1
                    count_of_if=count_of_if-1
                end
                
                # find elif or else
                if count_of_if==0 and i!=temp_i and
                    ( term(tl[i].TOKEN_STRING, "elif") or
                     term(tl[i].TOKEN_STRING, "else")
                     )
                    then
                    local end_index=i
                    local ahead_tl=tl[begin.val:end_index]
                    
                    local end_token=Token_init()
                    end_token.TOKEN_STRING="end"
                    end_token.TOKEN_CLASS="end"
                    ahead_tl.append(end_token)
                    
                    begin.val=end_index
                    output_tl.val=ahead_tl
                    return true
                end
                # elif then ... end
                if count_of_end==-1 and count_of_if==-1 then
                    local end_index=i+1
                    local ahead_tl=tl[begin.val:end_index]
                    
                    begin.val=end_index-1
                    output_tl.val=ahead_tl
                    return true
                end
            end
            
            # incomplete
            INCOMPLETE_STATEMENT=true
            return false
    
            
        end
        
        # else
        if term(tl[i].TOKEN_STRING, "else") then
            local count_of_if=0
            local count_of_end=0
            local temp_i=i
            for i<length_of_tl,i=i+1 then
                if term(tl[i].TOKEN_STRING, "if")
                or term(tl[i].TOKEN_STRING, "def")
                or term(tl[i].TOKEN_STRING, "while")
                or term(tl[i].TOKEN_STRING, "for") then
                    count_of_if=count_of_if+1
                    count_of_end=count_of_end+1
                end
                if term(tl[i].TOKEN_STRING, "end") then
                    count_of_if=count_of_if-1
                    count_of_end=count_of_end-1
                end
                
                #error
                if count_of_if==0 and i!=temp_i and (term(tl[i].TOKEN_STRING, "elif") or term(tl[i].TOKEN_STRING, "else")) then
                    Walley_Print_Error(TL_toString(temp_tl), "elif or else statements error", tl[i].TOKEN_START)
                end
                
                # finish else
                if count_of_end==-1 then
                    local end_index=i+1
                    local ahead_tl=tl[begin.val:end_index]
                    
                    begin.val=end_index-1
                    output_tl.val=ahead_tl
                    return true

                end
            end
            
            INCOMPLETE_STATEMENT=true
            return false
        end
    
        # end->
        # end
        if term(tl[i].TOKEN_STRING, "end") then
            local end_index=i
            if begin.val<i then
                local ahead_tl=tl[begin.val:end_index]
                
                begin.val=end_index
                output_tl.val=ahead_tl
                return true
            
            else
                begin.val=end_index
            end
            
            
            end_index=i+1
            local ahead_tl=tl[begin.val:end_index]
            
            begin.val=end_index
            output_tl.val=ahead_tl
            return true
        end
    end
    if begin.val<length_of_tl then
        local ahead_tl=tl[begin.val:length_of_tl]
       
        begin.val=length_of_tl
        output_tl.val=ahead_tl
        return true
    end
    
    return false
end

#= walley_parser.wy

# Generate AST
def parser(tl) then
    # reset TREE_INDEX value
    TREE_INDEX=0
    
    local output_tree=TREE_init("walley_statements")
    
    if len(tl)==0 then
        return output_tree
    end

    if walley_statements(output_tree, tl)==false and INCOMPLETE_STATEMENT==false then
        console.log("Fail to parse statements\n")
    end

    #TREE_print(output_tree)
    
     
    return output_tree
end

